<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Kubernetes 之 Service 與 kube-proxy 深入理解</title>
      <link href="2021/05/23/Kubernetes-%E4%B9%8B-Service-%E8%88%87-Kube-proxy-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"/>
      <url>2021/05/23/Kubernetes-%E4%B9%8B-Service-%E8%88%87-Kube-proxy-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>學習 Kubernetes 的路上 <code>Service</code> 可以說是再常見不過的元件之一。我們都知道 <code>Service</code> 的目的就是提供單一的 endpoint 給 clients 去訪問其背後所代理的 <code>Pods</code> ，而今天我們就來探索 Kubernetes 到底如何實作它的吧！</p><span id="more"></span><h2 id="初識-Service-原理"><a href="#初識-Service-原理" class="headerlink" title="初識 Service 原理"></a>初識 Service 原理</h2><p>可以從 <a href="https://kubernetes.io/docs/concepts/services-networking/service/#proxy-mode-iptables">Kubernetes 官網</a>得知每個節點上都會運行一個 <code>kube-proxy</code> 。它主要負責監控 k8s control plane 上 Service 資源的新增與刪除，並根據以上的動作對本機的 iptables 進行 iptables rules 的修改。那麼這些 iptables rules 就是負責攔截前往 <code>Service</code> (<em>ClusterIP:port</em>) 的網路流量，並重新導向到 Service 所代理的其中一個 endpoint (<code>Pod</code>)。</p><p><img src="https://d33wubrfki0l68.cloudfront.net/27b2978647a8d7bdc2a96b213f0c0d3242ef9ce0/e8c9b/images/docs/services-iptables-overview.svg" width="600" height="400"/>（圖一）</p><p>由上述官方對 <code>Service</code> 的解釋，我們可以得知黑魔法就隱藏在 iptables 裏頭。也就是說不論網路封包如何的路由都逃不過 iptables flow chart（如圖二），至於細節請參考<a href="http://linux.vbird.org/linux_server/0250simple_firewall.php">鳥哥的文章</a>。</p><p><img src="https://i.imgur.com/ZXXvi23.png" width="600" height="500"/>（圖二）</p><h2 id="問題情境"><a href="#問題情境" class="headerlink" title="問題情境"></a>問題情境</h2><p>基本上在使用 Kubernetes 的 <code>Service</code> 時有上面的觀念就游刃有餘了，但是如果要對它進行 debug 或是深入探討其實還是得打開 iptables 瞧瞧。最近就遇到一個神秘的問題 - <em>Nodeport Service 的 ExternalTrafficPolicy 設為 Local 時，如果從沒有 Pod 的節點（worker2）上去訪問節點自身的 IP 和 NodePort (worker2_IP:node_port) 時竟然也可以訪問的到服務</em>。</p><p>如果理解 <code>externalTrafficPolicy: Local</code> 這個參數就知道，流量打進節點的 IP 和 NodePort 時不會使用預設的 random 方式去選擇 <code>Pod</code> ，而是<strong>就地</strong>存取該節點上 <code>Service</code> 所代理的 <code>Pod</code> ，那怎麼還會訪問的到呢？因此我就不得不打開節點的 iptables 來一探究竟，去追蹤 <code>kube-proxy</code> 到底設定了哪些 rules ！</p><p><img src="https://i.imgur.com/vrlMlkR.png">（圖三）</p><h2 id="K8s-cluster-系統環境描述"><a href="#K8s-cluster-系統環境描述" class="headerlink" title="K8s cluster 系統環境描述"></a>K8s cluster 系統環境描述</h2><p>以我的環境為範例使用 <code>kubectl get no,svc,po -owide</code> 得到以下資訊</p><p><a href="https://hackmd.io/fkajt27iSbSXFAwbZmrAEg">deployment 和 service 的 yaml 範例</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">NAME           STATUS   ROLES                  AGE    VERSION   INTERNAL-IP    EXTERNAL-IP   OS-IMAGE            KERNEL-VERSION     CONTAINER-RUNTIME</span><br><span class="line">node&#x2F;master1   Ready    control-plane,master   5d1h   v1.21.0   172.20.20.12   &lt;none&gt;        Ubuntu 20.04.2 LTS   5.4. 0-73-generic   docker:&#x2F;&#x2F;20.10.2</span><br><span class="line">node&#x2F;master2   Ready    control-plane,master   5d1h   v1.21.0   172.20.20.13   &lt;none&gt;        Ubuntu 20.04.2 LTS   5.4. 0-73-generic   docker:&#x2F;&#x2F;20.10.2</span><br><span class="line">node&#x2F;master3   Ready    control-plane,master   5d1h   v1.21.0   172.20.20.14   &lt;none&gt;        Ubuntu 20.04.2 LTS   5.4. 0-73-generic   docker:&#x2F;&#x2F;20.10.2</span><br><span class="line">node&#x2F;worker1   Ready    &lt;none&gt;                 5d1h   v1.21.0   172.20.20.15   &lt;none&gt;        Ubuntu 20.04.2 LTS   5.4. 0-73-generic   docker:&#x2F;&#x2F;20.10.2</span><br><span class="line">node&#x2F;worker2   Ready    &lt;none&gt;                 5d1h   v1.21.0   172.20.20.16   &lt;none&gt;        Ubuntu 20.04.2 LTS   5.4. 0-73-generic   docker:&#x2F;&#x2F;20.10.2</span><br><span class="line">node&#x2F;worker3   Ready    &lt;none&gt;                 5d1h   v1.21.0   172.20.20.17   &lt;none&gt;        Ubuntu 20.04.2 LTS   5.4. 0-73-generic   docker:&#x2F;&#x2F;20.10.2</span><br><span class="line"></span><br><span class="line">NAME                 TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)        AGE     SELECTOR</span><br><span class="line">service&#x2F;kubernetes   ClusterIP   10.96.0.1       &lt;none&gt;        443&#x2F;TCP        5d1h    &lt;none&gt;</span><br><span class="line">service&#x2F;my-nginx     NodePort    10.104.89.245   &lt;none&gt;        80:30294&#x2F;TCP   4d20h   run&#x3D;my-nginx</span><br><span class="line"></span><br><span class="line">NAME                            READY   STATUS    RESTARTS   AGE   IP           NODE      NOMINATED NODE   READINESSGATES</span><br><span class="line">pod&#x2F;my-nginx-5b56ccd65f-8rww7   1&#x2F;1     Running   0          5d    10.244.4.3   worker3   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">pod&#x2F;my-nginx-5b56ccd65f-bxh9v   1&#x2F;1     Running   0          5d    10.244.5.4   worker1   &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></table></figure><h2 id="分析不同請求-iptables-flow-chart-的流程"><a href="#分析不同請求-iptables-flow-chart-的流程" class="headerlink" title="分析不同請求 iptables flow chart 的流程"></a>分析不同請求 iptables flow chart 的流程</h2><p>現在不僅要探討上面的問題，也藉此來深入理解 Service 是如何透過 iptables 來達成的吧！因此這裡主要分析 client request 使用以下三種方式來訪問 <code>service/my-nginx</code> 時，整個 iptables flow 到底經過哪些 chains (<em>以我的 k8s cluster 為範例</em>) :</p><ol><li><p>worker2 以外的主機對 worker2 發送的請求<br> <code>curl 172.20.20.16:30294</code></p></li><li><p>任意主機對 worker3 發送請求<br> <code>curl 172.20.20.17:30294</code></p></li><li><p>從 worker2 對本機發送的請求<br> <code>curl 172.20.20.16:30294</code></p></li></ol><p><img src="https://i.imgur.com/0JeNJqo.png" width="800" height="500"/>（圖四）</p><p>(<em><strong>下面案例的 iptables chains 已經重新排序並省略不在討論內的規則</strong></em>)</p><h3 id="Case-1-worker2-以外的主機對-worker2-發送的請求"><a href="#Case-1-worker2-以外的主機對-worker2-發送的請求" class="headerlink" title="Case 1 : worker2 以外的主機對 worker2 發送的請求"></a>Case 1 : worker2 以外的主機對 worker2 發送的請求</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># worker2</span><br><span class="line"># NAT table - PREROUTING chain</span><br><span class="line"></span><br><span class="line">1. -A PREROUTING -m comment --comment &quot;kubernetes service portals&quot; -j KUBE-SERVICES</span><br><span class="line"></span><br><span class="line">2. -A KUBE-SERVICES -m comment --comment &quot;kubernetes service nodeports; NOTE: this must be the last rule in this chain&quot; -m addrtype --dst-type LOCAL -j KUBE-NODEPORTS</span><br><span class="line"></span><br><span class="line">3. -A KUBE-NODEPORTS -p tcp -m comment --comment &quot;default&#x2F;my-nginx&quot; -m tcp --dport 30294 -j  KUBE-XLB-L65ENXXZWWSAPRCR</span><br><span class="line"></span><br><span class="line">4. -A KUBE-XLB-L65ENXXZWWSAPRCR -s 10.244.0.0&#x2F;16 -m comment --comment &quot;Redirect pods trying to reach external loadbalancer VIP to clusterIP&quot; -j KUBE-SVC-L65ENXXZWWSAPRCR</span><br><span class="line">   -A KUBE-XLB-L65ENXXZWWSAPRCR -m comment --comment &quot;masquerade LOCAL traffic for default&#x2F;my-nginx LB IP&quot; -m addrtype --src-type LOCAL -j KUBE-MARK-MASQ</span><br><span class="line">   -A KUBE-XLB-L65ENXXZWWSAPRCR -m comment --comment &quot;route LOCAL traffic for default&#x2F;my-nginx LB IP to service chain&quot; -m addrtype --src-type LOCAL -j KUBE-SVC-L65ENXXZWWSAPRCR</span><br><span class="line"></span><br><span class="line">5. -A KUBE-XLB-L65ENXXZWWSAPRCR -m comment --comment &quot;default&#x2F;my-nginx has no local endpoints&quot; -j KUBE-MARK-DROP</span><br><span class="line"></span><br><span class="line">6. -A KUBE-MARK-DROP -j MARK --set-xmark 0x8000&#x2F;0x8000</span><br></pre></td></tr></table></figure><p>(<a href="https://i.imgur.com/CM8VNmV.png">iptables flow chart of any host except worker2 to worker2</a>)</p><ul><li><p><code>1. ~ 2.</code> 封包符合目的位址為 LOCAL 所以會進入 <code>KUBE-NODEPORTS</code> chain</p></li><li><p><code>3.</code> 封包符合目的埠號為 30294 所以會進入 <code>KUBE-XLB-L65ENXXZWWSAPRCR</code> chain</p></li><li><p><code>4.</code> 封包並不符合來源位址是 <code>10.244.0.0/16</code> 或是本機，因此會<em>直接跳過</em>這些歸則</p></li><li><p><code>5. ~ 6.</code> 封包符合來自 worker2 或是 <code>10.244.0.0/16</code> <strong>以外</strong>的封包，所以會進入 <code>KUBE-MARK-DROP</code> chain 並且被標記上 <code>0x8000/0x8000</code></p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># worker2</span><br><span class="line"># FILTER table - INPUT chain</span><br><span class="line"></span><br><span class="line">6. -A INPUT -j KUBE-FIREWALL</span><br><span class="line"></span><br><span class="line">7. -A KUBE-FIREWALL -m comment --comment &quot;kubernetes firewall for dropping marked packets&quot; -m mark --mark 0x8000&#x2F;0x8000 -j DROP</span><br></pre></td></tr></table></figure><p>在封包正式進入主機之前還會經過 filter table 的 input chain 做過濾</p><ul><li><p><code>6.</code> 任何封包進入主機前都先進 <code>KUBE-FIREWALL</code> chain 做檢查</p></li><li><p><code>7.</code> 這條規則很明確的表示凡帶有 mark 為 <code>0x8000/0x8000</code> 的封包都會被 <code>DROP</code> ，因此在 <code>5. ~ 6.</code> 所執行的標記就會導致該封包被丟棄</p></li></ul><p>從上面的 iptables chains flow 可以了解到 <code>externalTrafficPolicy: Local</code> 是如何實作請求發送到沒有提供服務的節點的情況，其實就是把封包丟棄而已。</p><h3 id="Case-2-任意主機對-worker3-發送請求"><a href="#Case-2-任意主機對-worker3-發送請求" class="headerlink" title="Case 2 : 任意主機對 worker3 發送請求"></a>Case 2 : 任意主機對 worker3 發送請求</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># worker3</span><br><span class="line"># NAT table - PREROUTING chain</span><br><span class="line"></span><br><span class="line">1. -A PREROUTING -m comment --comment &quot;kubernetes service portals&quot; -j KUBE-SERVICES</span><br><span class="line"></span><br><span class="line">2. -A KUBE-SERVICES -m comment --comment &quot;kubernetes service nodeports; NOTE: this must be the last rule in this chain&quot; -m addrtype --dst-type LOCAL -j KUBE-NODEPORTS</span><br><span class="line"></span><br><span class="line">3. -A KUBE-NODEPORTS -p tcp -m comment --comment &quot;default&#x2F;my-nginx&quot; -m tcp --dport 30294 -j KUBE-XLB-L65ENXXZWWSAPRCR</span><br><span class="line"></span><br><span class="line">4. -A KUBE-XLB-L65ENXXZWWSAPRCR -m comment --comment &quot;Balancing rule 0 for default&#x2F;my-nginx&quot; -j KUBE-SEP-HL43S2RPGOP5RW4C</span><br><span class="line"></span><br><span class="line">5. -A KUBE-SEP-HL43S2RPGOP5RW4C -p tcp -m comment --comment &quot;default&#x2F;my-nginx&quot; -m tcp -j DNAT --to-destination 10.244.4.3:80</span><br></pre></td></tr></table></figure><p><a href="https://i.imgur.com/Ou9ykvN.png">iptables flow chart of any host to worker3</a></p><ul><li><p><code>1. ~ 2.</code> 封包符合目的位址為 LOCAL 所以會先進 <code>KUBE-SERVICES</code> 再進 <code>KUBE-NODEPORTS</code> chain</p></li><li><p><code>3. ~ 4.</code> 封包符合目的埠號為 30294 所以會進入 <code>KUBE-SEP-HL43S2RPGOP5RW4C</code> 。這條規則很明確的將封包路由到 <code>KUBE-SEP-HL43S2RPGOP5RW4C</code> (service endpoint) 而非 <code>KUBE-SVC-L65ENXXZWWSAPRCR</code> 。因此不會從所有的 service endpoints 中隨機路由到其中一個。</p></li><li><p><code>5.</code> 直接將封包 <code>DNAT</code> 到 worker3 的 <code>Pod</code> 上</p></li></ul><p>最後一個 case 的 iptables chains flow 也完美解答了 <code>externalTrafficPolicy: Local</code> 是如何實作不經過 <code>KUBE-SVC-XXXX</code> 而直接路由到本地可以提供服務的 <code>Pod</code> 上。</p><h3 id="Case-3-worker2-對本機發送的請求"><a href="#Case-3-worker2-對本機發送的請求" class="headerlink" title="Case 3 : worker2 對本機發送的請求"></a>Case 3 : worker2 對本機發送的請求</h3><p>worker2 to worker2 的封包流向根據（圖四）是由 nat table 的 output chain 開始</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># worker2 iptables</span><br><span class="line"># NAT tables - OUTPUT chain</span><br><span class="line"></span><br><span class="line">1. -A OUTPUT -m comment --comment &quot;kubernetes service portals&quot; -j KUBE-SERVICES</span><br><span class="line"></span><br><span class="line">2. -A KUBE-SERVICES -m comment --comment &quot;kubernetes service nodeports; NOTE: this must be the last rule in this chain&quot; -m addrtype --dst-type LOCAL -j KUBE-NODEPORTS</span><br><span class="line"></span><br><span class="line">3. -A KUBE-NODEPORTS -s 127.0.0.0&#x2F;8 -p tcp -m comment --comment &quot;default&#x2F;my-nginx&quot; -m tcp --dport 30294 -j KUBE-MARK-MASQ</span><br><span class="line"></span><br><span class="line">4. -A KUBE-MARK-MASQ -j MARK --set-xmark 0x4000&#x2F;0x4000</span><br><span class="line"></span><br><span class="line">5. -A KUBE-NODEPORTS -p tcp -m comment --comment &quot;default&#x2F;my-nginx&quot; -m tcp --dport 30294 -j KUBE-XLB-L65ENXXZWWSAPRCR</span><br><span class="line"></span><br><span class="line">6. -A KUBE-XLB-L65ENXXZWWSAPRCR -m comment --comment &quot;route LOCAL traffic for default&#x2F;my-nginx LB IP to service chain&quot; -m addrtype --src-type LOCAL -j KUBE-SVC-L65ENXXZWWSAPRCR</span><br><span class="line"></span><br><span class="line">7. -A KUBE-SVC-L65ENXXZWWSAPRCR -m comment --comment &quot;default&#x2F;my-nginx&quot; -m statistic --mode random --probability 0.50000000000 -j KUBE-SEP-HL43S2RPGOP5RW4C</span><br><span class="line">   -A KUBE-SVC-L65ENXXZWWSAPRCR -m comment --comment &quot;default&#x2F;my-nginx&quot; -j KUBE-SEP-CUCTBSPZ5432UVNG</span><br><span class="line">   </span><br><span class="line">8. -A KUBE-SEP-HL43S2RPGOP5RW4C -p tcp -m comment --comment &quot;default&#x2F;my-nginx&quot; -m tcp -j DNAT --to-destination 10.244.4.3:80</span><br><span class="line">   -A KUBE-SEP-CUCTBSPZ5432UVNG -p tcp -m comment --comment &quot;default&#x2F;my-nginx&quot; -m tcp -j DNAT --to-destination 10.244.5.4:80</span><br></pre></td></tr></table></figure><p>(<a href="https://i.imgur.com/rGk3YE7.png">iptables flow chart of worker2 to worker2</a>)</p><ul><li><p><code>1. ~ 4.</code> 封包符合來源位址為 <code>127.0.0.0/8</code> 、傳輸層使用 tcp 以及目的埠號為 30294 ，因此封包會標記上 (mark) <code>0x4000/0x4000</code>。 <em>mark 是為了將封包分類以方便之後的處理</em>。</p></li><li><p><code>5. ~ 6.</code> 封包符合來源為 LOCAL 並且目的埠號為 30294，所以封包會進入<code>KUBE-XLB-L65ENXXZWWSAPRCR</code> 再進入 <code>KUBE-SVC-L65ENXXZWWSAPRCR</code> (也就是 <code>service/my-nginx</code>) </p></li><li><p><code>7.</code> 第一個規則表明只有 50% 的機會會從 <code>KUBE-SVC-L65ENXXZWWSAPRCR</code> 路由到 <code>KUBE-SEP-HL43S2RPGOP5RW4C</code> ，如果沒抽中則會路由到 <code>KUBE-SEP-CUCTBSPZ5432UVNG</code>。這兩個 KUBE-SEP-XXXX 事實上就是 <code>service/my-nginx</code> 所代理的兩個 <code>Pods</code></p></li><li><p><code>8.</code> 最後兩條規則會依據 <code>7.</code> 是執行哪條規則來將封包 <code>DNAT</code> 到 worker3 或是 worker1 上的 <code>Pod</code></p></li></ul><h4 id="Kube-proxy-如何處理沒有-Pod-的節點訪問自身"><a href="#Kube-proxy-如何處理沒有-Pod-的節點訪問自身" class="headerlink" title="Kube-proxy 如何處理沒有 Pod 的節點訪問自身"></a>Kube-proxy 如何處理沒有 Pod 的節點訪問自身</h4><p>由上面 iptables chains flow 可以很清楚的看到，像這樣子的訪問會經歷和 ClusterIP Service 一樣的路由方式。也就是使用機率抽籤，將去到 <code>service/my-nginx</code> 的網路流量隨機的路由到該 <code>Service</code> 所代理的 <code>Pod</code> 。</p><p><img src="https://i.imgur.com/UE8bQ8k.png">（圖五）</p><h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><p>Kubernetes 本身涵蓋許多的知識領域，而我個人認為網路的部分不論是在學習或是除錯上都相對的不容易。事實上，本篇只提及 <code>Service</code> 是如何透過 kube-proxy 和 iptables 來幫助我們實現封包的過濾和修改，至於封包如何透過 <a href="https://github.com/containernetworking/cni">CNI</a> 在 <code>Pod</code> 或是 server 之間路由就是另一個故事了!</p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kube-proxy </tag>
            
            <tag> iptables </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解決 ESXi 6.7 單機版複製 VM 的問題</title>
      <link href="2021/05/08/%E8%A7%A3%E6%B1%BA-ESXi-6-7-%E5%96%AE%E6%A9%9F%E7%89%88%E8%A4%87%E8%A3%BD-VM-%E7%9A%84%E5%95%8F%E9%A1%8C/"/>
      <url>2021/05/08/%E8%A7%A3%E6%B1%BA-ESXi-6-7-%E5%96%AE%E6%A9%9F%E7%89%88%E8%A4%87%E8%A3%BD-VM-%E7%9A%84%E5%95%8F%E9%A1%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近因為需要架設 Kubernetes 高可用的 Control Plane 叢集，因此想要複製多台 VMs 在 ESXi 上。但因為 ESXi (Standalone) 它並沒有提供其他可用的 Web UI 去配置，只能通過上傳 <code>ovf</code> 和 <code>vmdk</code> 檔案來建立新 VM ，所以會花掉大量的時間。因此最後只好使用 ssh 到 ESXi Manager 來設定。</p><span id="more"></span><h2 id="前置作業-Prerequisites"><a href="#前置作業-Prerequisites" class="headerlink" title="前置作業 Prerequisites"></a>前置作業 Prerequisites</h2><ul><li><p>開啟 ESXi 的 SSh</p><p>  <img src="https://i.imgur.com/I7GUqjU.png"></p></li></ul><h2 id="複製-VM-的步驟"><a href="#複製-VM-的步驟" class="headerlink" title="複製 VM 的步驟"></a>複製 VM 的步驟</h2><ol><li><p>將預備複製的 VM 先關機並<strong>建立快照</strong></p><p> <img src="https://i.imgur.com/S4HDqkN.png"></p></li><li><p>切換目錄到 <code>/vmfs/volumes/datastore1</code></p><blockquote><p>cd /vmfs/volumes/datastore1</p></blockquote></li><li><p>創建新 VM 的 <code>new_vm</code> 資料夾</p><blockquote><p>mkdir new_vm</p></blockquote></li><li><p>由 origin 的快照去 clone 出一個新的 vm</p><blockquote><p>vmkfstools -i ./origin/origin-000001.vmdk ./new_vm/new_vm.vmdk -d thin -a buslogic</p></blockquote></li><li><p>選擇 <strong>建立新的虛擬機器</strong></p><p> <img src="https://i.imgur.com/Twldkjp.png"></p></li><li><p><strong>自訂設定</strong> -&gt; <strong>新增硬碟</strong> -&gt; <strong>現有硬碟</strong></p><p> <img src="https://i.imgur.com/jJkLnmX.png"></p></li><li><p>選擇已經 clone 好的 <code>new_vm.vmdk</code></p><p> <img src="https://i.imgur.com/csSlrxG.png"></p></li></ol><ol start="8"><li><p>可以看已經有新增新的硬碟並可以調整各種資源的大小</p><p> <img src="https://i.imgur.com/Xy8tvnN.png"></p></li><li><p>按下完成，恭喜 vm 建立成功！</p></li></ol><h2 id="小小結論"><a href="#小小結論" class="headerlink" title="小小結論"></a>小小結論</h2><p>原則上 ESXi 單機版的 Web UI 還是有許多的限制（免費仔），因此可能經常會需要用 CLI 的方式跟 ESXi Manager 打交道！</p>]]></content>
      
      
      <categories>
          
          <category> ESXi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ESXi 6.7 Standalone </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kubernetes 筆記 - Component 3</title>
      <link href="2021/03/14/Container-%E7%AE%A1%E7%90%86-%E7%AD%86%E8%A8%98-%E5%9B%9B-kubernetes-Component-%E4%B8%89/"/>
      <url>2021/03/14/Container-%E7%AE%A1%E7%90%86-%E7%AD%86%E8%A8%98-%E5%9B%9B-kubernetes-Component-%E4%B8%89/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上篇提到使用 Kubernetes 的一些基本的網路元件。這次本篇主要在紀錄 Kubernetes 常用的水平擴展元件 Deployment 的觀念以及使用方法。最後會提到 Kubernetes 缺乏的要素以及如何透過 Service Mesh 的引入，在具體上給 Kubernetes 增添什麼樣的變化。</p><span id="more"></span><h1 id="Depolyment"><a href="#Depolyment" class="headerlink" title="Depolyment"></a>Depolyment</h1><p><strong>讓服務可以 zero downtime 升級的組建</strong> （不停機）</p><p><img src="https://i.imgur.com/6d5EZOJ.png"></p><ol><li>自動產生和維護 <code>ReplicaSet</code><ul><li><img src="https://i.imgur.com/WdMKWc3.png"></li></ul></li><li>可隨時 rollback 到先前的版本 (預設是保留兩個版本)<ul><li><img src="https://i.imgur.com/jBZ3zlS.png"></li></ul></li><li>Version-based Rollout (<a href="https://dev.to/mostlyjason/intro-to-deployment-strategies-blue-green-canary-and-more-3a3">Canary deployment</a>)<ul><li><img src="https://i.imgur.com/GXjBSMV.png" width="350" height="450" /></li></ul></li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubia-dp</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">kubia</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">kubia</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">kubia</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">kubia</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">oliwave/kubia</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure><h1 id="LAB-在-k8s-上實踐不同版本服務的-rollout"><a href="#LAB-在-k8s-上實踐不同版本服務的-rollout" class="headerlink" title="LAB : 在 k8s 上實踐不同版本服務的 rollout"></a>LAB : 在 k8s 上實踐不同版本服務的 rollout</h1><p><a href="https://labs.play-with-k8s.com/">Play with k8s</a></p><ol><li>複製以下檔案<ul><li><code>kubia-dp-v1.yaml</code><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubia-dp</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">kubia</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">kubia</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">kubia</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">kubia</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">oliwave/kubia:v1</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure></li><li><code>kubia-dp-v2.yaml</code><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubia-dp</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">kubia</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">kubia</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">kubia</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">kubia</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">oliwave/kubia:v2</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure></li><li><code>kubia-svc.yaml</code><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubia</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="comment">#sessionAffinity: ClientIP # 根據需要來設定</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span> <span class="comment"># service 的 port</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">8080</span> <span class="comment"># service 會將封包轉送的 port</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">kubia</span></span><br></pre></td></tr></table></figure></li><li><code>ingress.yaml</code><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubia</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">kubia.example.com</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">serviceName:</span> <span class="string">kubia</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure></li></ul></li><li><code>kubectl apply -f kubia-dp-v1.yaml</code><ul><li><code>kubectl get po -o wide</code> 檢查 pod 是否部署在叢集中</li><li><code>kubectl get rs</code> 檢查 replicasets 是否有被 deployment 自動的產生</li></ul></li><li><code>kubectl apply -f kubia-svc.yaml</code><ul><li><code>kubectl get svc</code> 取得 Service 的 IP</li></ul></li><li><code>kubectl apply -f ingress.yaml</code></li><li><code>while true; do curl &lt;service IP&gt;; done</code><ul><li>不停得向服務發送請求</li></ul></li><li><code>kubectl apply -f kubia-dp-v2.yaml</code></li></ol><h1 id="Service-Mesh"><a href="#Service-Mesh" class="headerlink" title="Service Mesh"></a>Service Mesh</h1><h2 id="傳統-Microservice-不同服務間的交互"><a href="#傳統-Microservice-不同服務間的交互" class="headerlink" title="傳統 Microservice 不同服務間的交互"></a>傳統 Microservice 不同服務間的交互</h2><!-- <img src="https://i.imgur.com/BHXiC2F.png" width="600" height="300" /></br> --><p>每個微服務必須個別實現 <code>Security (公有雲)</code>、<code>Tracing</code>、<code>Logging</code> 等機制。</p><p><img src="https://i.imgur.com/8ySmkba.png"></p><ol><li>導致 <strong>不易開發和維護</strong></li><li>違反微服務 <strong>Do One Thing, Do it Best</strong> 的原則</li></ol><h2 id="What-is-Service-mesh"><a href="#What-is-Service-mesh" class="headerlink" title="What is Service mesh ?"></a>What is Service mesh ?</h2><ol><li>在不影響既有 Application container 的情況下，植入 Sidecar Container </li><li>Sidecar Container 負責管理和設定不同服務實體之間的網路通訊</li></ol><p><img src="https://i.imgur.com/s9HFOHg.png"></p><p>輕鬆簡單地為現有已經部署的微服務進行 <code>load-balancing</code>, <code>service-to-service authentication</code>, <code>monitoring</code> 等等，而 <strong>無需改動現有的服務</strong></p><h1 id="Istio"><a href="#Istio" class="headerlink" title="Istio"></a>Istio</h1><!-- > FIXME: 簡述 Istio 和 Service mesh 的關係 --><p>Istio 在架構上大量的使用 Service Mesh 模式</p><h2 id="實現-Sidecar-Injection-的方式"><a href="#實現-Sidecar-Injection-的方式" class="headerlink" title="實現 Sidecar Injection 的方式"></a>實現 Sidecar Injection 的方式</h2><img src="https://banzaicloud.com/img/blog/istio/sidecar-lifecycle-1.gif" width="450" height="500" /><ul><li><code>istio-init</code> (<a href="https://kubernetes.io/docs/concepts/workloads/pods/init-containers/">init container</a>) 負責修改 iptables 的規則，讓所有進來或出去 Pod 的流量都經過 sidecar proxy</li><li><code>istio-proxy</code> 就是 sidecar proxy (based on <a href="https://www.envoyproxy.io/">Envoy</a>)</li></ul><h2 id="架構"><a href="#架構" class="headerlink" title="架構"></a>架構</h2><!-- > FIXME: pod 要連到其他的 service 時需要經由自己的 service 嗎？ --><p><img src="https://i.imgur.com/7iwg60B.png" width="500" height="500" /></br></p><p>Istio service mesh 在邏輯上可以分為 <code>Control plane</code> 和 <code>Data plane</code></p><ul><li><code>Data plane</code> 是由一組 proxies (<strong>envoy</strong>) 所組成，並以 <strong>Sidecar</strong> 的方式來部署</li><li><code>Control plane</code> 專門用來管理和設定這些 <em>路由流量</em> 的 proxies </li></ul><h4 id="Pilot"><a href="#Pilot" class="headerlink" title="Pilot"></a>Pilot</h4><p><strong>為 Envoy Sidecar 提供 Service Discovery 的服務</strong></p><!-- ![](https://i.imgur.com/0cNCHJi.png) --><img src="https://i.imgur.com/0cNCHJi.png" width="500" height="500" /><h4 id="Citadel"><a href="#Citadel" class="headerlink" title="Citadel"></a>Citadel</h4><!-- > FIXME: 怎麼認證？ --><p>Enables strong service-to-service and end-user authentication with built-in identity and credential management.</p><hr><h4 id="Sidecar-deployment-的效果"><a href="#Sidecar-deployment-的效果" class="headerlink" title="Sidecar deployment 的效果"></a>Sidecar deployment 的效果</h4><ol><li>使 Istio 可以將大量有關流量的訊號抽取出來成為不同的 <em>屬性</em>。Istio 可以通過這些屬性來執行不同的 <em>政策決定 (policy decisions)</em> ，並將他們送到監控系統來提供當前 service mesh 的行為資訊。</li><li>可以將不同的功能加入到現有 Istio 而無需重構架構或是程式碼。</li></ol><hr><hr><h4 id="Traffic"><a href="#Traffic" class="headerlink" title="Traffic"></a>Traffic</h4><p>流量在 Istio 的定義中可以分為 <code>Data plane traffic</code> 和 <code>Control plane traffic</code> 。 Envoy proxies 是 Istio 架構中唯一與 Data plane traffic 有關的組件。</p><hr><h2 id="流量管理"><a href="#流量管理" class="headerlink" title="流量管理"></a>流量管理</h2><p>Istio 的流量管理模組是使用 <strong>envoy proxies</strong> ，隨著你的服務一起部署上去。<strong>所有的流量不論是由 service mesh 接收或送出都會由 envoy 來 proxy</strong>。</p><p><img src="https://i.imgur.com/5LmX7Ux.png"></p><hr><p><code>Envoy</code> 是一種 L7 proxy 和 communication bus (<strong>API gateway</strong>) 被設計用來在大型 <strong><code>SOA</code> Service-oriented Architectures</strong> 上。</p><hr><p>透過簡單規則配置和流量路由控制服務之間的流量和API調用的流量。簡化了 Service 一些屬性上的配置。</p><ol><li><a href="https://ithelp.ithome.com.tw/articles/10194912">Circiut breaker</a><ul><li>服務自我檢查的機制 </li><li>避免單一服務崩潰，造成整體服務連鎖崩壞</li></ul></li><li>A/B Testing<br> <img src="https://i.imgur.com/epUV9qO.png"></li><li>Canary rollouts</li><li>Failure recovery</li></ol><h3 id="Kubernetes-就有做了為什麼還需要-Istio"><a href="#Kubernetes-就有做了為什麼還需要-Istio" class="headerlink" title="Kubernetes 就有做了為什麼還需要 Istio ?"></a>Kubernetes 就有做了為什麼還需要 Istio ?</h3><h4 id="舉例：-Version-based-Rollout-Canary-deployment"><a href="#舉例：-Version-based-Rollout-Canary-deployment" class="headerlink" title="舉例： Version-based Rollout (Canary deployment)"></a>舉例： Version-based Rollout (Canary deployment)</h4><ul><li>k8s 使用 <strong>pod 的數量</strong> 來調整不同版本的比例  <img src="https://i.imgur.com/GXjBSMV.png" width="350" height="450" />  </li><li>Istio 透過 <code>Virtual service</code> 直接控制流量進入不同流量的比例  <img src="https://i.imgur.com/FCI30dN.png" width="350" height="450" /></li></ul>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Microservice </tag>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kubernetes 筆記 - Component 2</title>
      <link href="2021/02/11/Container%20%E7%AE%A1%E7%90%86%20(%E7%AD%86%E8%A8%98%20%E4%B8%89)%20-%20kubernetes%20/"/>
      <url>2021/02/11/Container%20%E7%AE%A1%E7%90%86%20(%E7%AD%86%E8%A8%98%20%E4%B8%89)%20-%20kubernetes%20/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上篇提到使用 Kubernetes 的一些基本元件。這次本篇主要在紀錄 Kubernetes 常用有關網路元件的介紹和如何使用：</p><ul><li>Service</li><li>Ingress</li></ul><span id="more"></span><h1 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h1><h2 id="Service-Discovery"><a href="#Service-Discovery" class="headerlink" title="Service Discovery"></a>Service Discovery</h2><p>Pod 重啟或重新部署都會產生新的 IP ，透過 Service 當作媒介，管理與監控這些 Pods 並對外暴露自己的 IP 供別人訪問存取。</p><img src="https://i.imgur.com/dmv1ReS.png" width="800" height="500" /><h2 id="Serivce-物件"><a href="#Serivce-物件" class="headerlink" title="Serivce 物件"></a>Serivce 物件</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubia</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="comment"># sessionAffinity: ClientIP # 根據需要來設定</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span> <span class="comment"># service 的 port</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">8080</span> <span class="comment"># service 會將封包轉送的 port</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">kubia</span></span><br></pre></td></tr></table></figure><img src="https://i.imgur.com/1fqweH8.png" width="700" height="400" /><hr><ol><li>在 cluster 中若需要 <strong><a href="https://kubernetes.io/docs/tasks/access-application-cluster/connecting-frontend-backend/"><code>pod-to-pod</code></a></strong> 請求中，<strong>請使用 Service 的 name 作為 hostname 而非 Pod ip 。</strong><ul><li> 因為你非但不能在 Pod 被建立以前知道他的 IP ，即使可以 Pod 隨時都有可能重啟或重新部署而改變 IP。</li><li><blockquote><p><a href="http://kubia/">http://kubia</a>.&lt;namespace&gt;</p></blockquote></li></ul></li><li><code>sessionAffinity</code>  只有 ClientIP 和 None 兩種模式，<strong>並沒有 cookie-based</strong> 。因為 K8s Service 是在 L4 而非 L7 所以只有 TCP 和 UDP</li></ol><hr><h3 id="多埠-Service-物件"><a href="#多埠-Service-物件" class="headerlink" title="多埠 Service 物件"></a>多埠 Service 物件</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubia</span></span><br><span class="line"><span class="attr">spec:</span> </span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span> <span class="comment"># 外部 80 轉送到內部 8080</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">8080</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">https</span> <span class="comment"># 443 轉送到 8443</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">443</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">8443</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">kubia</span></span><br></pre></td></tr></table></figure><h3 id="使用命名埠"><a href="#使用命名埠" class="headerlink" title="使用命名埠"></a>使用命名埠</h3><p><em>好處是萬一不是一個常見的 port 號，可以透過命名的方式讓結構更清晰</em></p><p><em>可以隨時更改底層 (Pod) 的 port 號而不會影響到上層的服務 (Service)</em></p><p>首先，先為 Pod 建立好 port 的名字</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">kubia</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span> <span class="comment"># 容器的 port 號 8080 命名為 http</span></span><br><span class="line">      <span class="attr">containerPort:</span> <span class="number">8080</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">https</span> <span class="comment"># 容器的 port 號 8443 命名為 https</span></span><br><span class="line">      <span class="attr">containerPort:</span> <span class="number">8443</span></span><br></pre></td></tr></table></figure><p>再來是為 Pod 建立好 Service </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="string">http</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">https</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">443</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="string">https</span></span><br></pre></td></tr></table></figure><hr><h4 id="為什麼-ping-不到-Service-的-IP"><a href="#為什麼-ping-不到-Service-的-IP" class="headerlink" title="為什麼 ping 不到 Service 的 IP ?"></a>為什麼 ping 不到 Service 的 IP ?</h4><img src="https://i.imgur.com/Vkv0jQB.png" width="500" height="500" /><ol><li><code>kube-proxy</code> 負責監控 Endpoints 的改變</li><li><code>kube-proxy</code> 如有服務訪問這組 IP 就會被 iptables 修改並且 forward 掉</li></ol><hr><h2 id="讓外部的用戶連線到-cluster-的-Service"><a href="#讓外部的用戶連線到-cluster-的-Service" class="headerlink" title="讓外部的用戶連線到 cluster 的 Service"></a>讓外部的用戶連線到 cluster 的 Service</h2><!-- ![](https://i.imgur.com/eonnWmB.png) --><img src="https://i.imgur.com/eonnWmB.png" width="700" height="500" /><p>讓外部來連線 Service 有以下幾種方式</p><ol><li><p>將 Service 的類型設為 <code>NodePort</code></p><ul><li>每一個在 cluster 裡面的 Node 都會開一個 Port ，然後把流量轉送到底層的 Service </li><li>該 Service 不僅可以透過 ClusterIP 和 Port 來訪問，也可以透過每個 Node 上的 Port</li></ul></li><li><p>將 Service 的類型設為 <code>LoadBalancer</code></p><ul><li>是 NodePort 的擴充版</li><li>是根據不同 cloud infrastructure 而定</li><li>用戶通過 load balancer 的 IP 來訪問 service</li></ul></li><li><p>建立 <code>Ingress</code> 資源，一種根本不同的機制，用於通過唯一 IP 公開多個服務</p><ul><li>它是在 Layer 7 上運作的</li></ul></li></ol><h3 id="NodePort"><a href="#NodePort" class="headerlink" title="NodePort"></a>NodePort</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubia-nodeport</span> </span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span> </span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span> <span class="comment"># 這是內部 cluster IP 的 port</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">8080</span> <span class="comment"># 這是 Pod 的 port</span></span><br><span class="line">    <span class="attr">nodePort:</span> <span class="number">30123</span> <span class="comment"># Service 可以從 Node 的 port 來被存取</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">kubia</span></span><br></pre></td></tr></table></figure><p>可以使用以下指令來檢查 NodePort Service </p><blockquote><p>kubectl get svc kubia-nodeport</p></blockquote><p><img src="https://i.imgur.com/WTTVeNc.png"></p><p>可以看到 <code>EXTERNAL-IP</code> 是 <code>&lt;nodes&gt;</code> ，也就是說該 Service 可以在每一個 node 上透過 30123 port 被存取。</p><img src="https://i.imgur.com/frEDH1l.png" width="600" height="500" /><!-- ![](https://i.imgur.com/frEDH1l.png) --><h3 id="LoadBalancer"><a href="#LoadBalancer" class="headerlink" title="LoadBalancer"></a>LoadBalancer</h3><ul><li><strong>用在公有雲上</strong>， cloud providers 通常會支援該模式。</li><li>與 NodePort 不同，它是透過唯一的 Public IP 來做存取。</li></ul><p><img src="https://i.imgur.com/rjN3ViF.png" width="600" height="500" /></br></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#...</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">LoadBalancer</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span> <span class="comment"># 這是內部 cluster IP 的 port</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">8080</span> <span class="comment"># 這是 Pod 的 port</span></span><br><span class="line"><span class="comment">#...    </span></span><br></pre></td></tr></table></figure><h3 id="Ingress"><a href="#Ingress" class="headerlink" title="Ingress"></a>Ingress</h3><p>單純定義一個 Service 並讓 Ingress 指向它</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#...</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubia</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span> <span class="comment"># service 的 port</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">8080</span> <span class="comment"># service 會將封包轉送的 port</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">kubia</span></span><br></pre></td></tr></table></figure><h2 id="連接-cluster-外部的-Service"><a href="#連接-cluster-外部的-Service" class="headerlink" title="連接 cluster 外部的 Service"></a>連接 cluster 外部的 Service</h2><h3 id="Service-與-Endpoints-的關係"><a href="#Service-與-Endpoints-的關係" class="headerlink" title="Service 與 Endpoints 的關係"></a>Service 與 Endpoints 的關係</h3><ul><li>Service 和 Pod 並不是直接有所連結的，而是有一個叫做 <strong>Endpoints</strong> 的資源在中間。</li><li><strong>Endpoints 資源(複數)是一組一組可供 Service 做 loadbalance 的 Pod socket 清單</strong></li></ul><blockquote><p>kubectl describe svc kubia</p></blockquote><p><img src="https://i.imgur.com/XfkaV9c.png"></p><blockquote><p>kubectl get endpoints kubia</p></blockquote><p><img src="https://i.imgur.com/1HNBfID.png"></p><hr><ol><li>如果 Service 有設定 Pod 的 label selector 就會自動產生 Endpoints 物件，<strong>並且幫你自動維護</strong>。</li><li>反之，必須自己建立 Endpoints 物件，<strong>並且必須與 Service 同名</strong>。</li></ol><hr><h3 id="自己設定-Service-Endpoints-的時機：連線到外部網路的服務"><a href="#自己設定-Service-Endpoints-的時機：連線到外部網路的服務" class="headerlink" title="自己設定 Service Endpoints 的時機：連線到外部網路的服務"></a>自己設定 Service Endpoints 的時機：連線到外部網路的服務</h3><ol><li><p>創建一個沒有 selector 的 Service</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">google-map</span> <span class="comment"># Service 的名字必須和 Endpoints 一樣</span></span><br><span class="line"><span class="attr">spec:</span>  <span class="comment"># 無需定義 selector</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure></li><li><p> 為沒有 selector 的 Service 創建 Endpoints</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Endpoints</span> </span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">google-map</span> <span class="comment"># Endpoints 的名字必須和 Service 的一樣</span></span><br><span class="line"><span class="attr">subsets:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">addresses:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">ip:</span> <span class="number">11.11</span><span class="number">.11</span><span class="number">.11</span> <span class="comment"># Service 將連接轉發到的端點的 IP</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">ip:</span> <span class="number">22.22</span><span class="number">.22</span><span class="number">.22</span> </span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure></li></ol><p><img src="https://i.imgur.com/ejnt4Nc.png" width="800" height="400" /></br></p><!-- ![](https://i.imgur.com/ejnt4Nc.png) --><p>Service 和 Endpoints 建立起來後，就可以讓 Pods 透過 Service 存取具有兩個外部端點。</p><hr><h3 id="連線到外部網路服務的另一種方式：ExternalName-Service"><a href="#連線到外部網路服務的另一種方式：ExternalName-Service" class="headerlink" title="連線到外部網路服務的另一種方式：ExternalName Service"></a>連線到外部網路服務的另一種方式：ExternalName Service</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">google-map</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">ExternalName</span> <span class="comment"># Service 的類型為 ExternalName</span></span><br><span class="line">  <span class="attr">externalName:</span> <span class="string">maps.googleapis.com</span> <span class="comment"># 真實服務的 FQDN</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><ul><li>Pod 呼叫外部的 API 就使用 <code>http://google-map</code></li><li>不影響 Pod 的情況下，在 ExternalName Service 上改變存取的外部服務的網址</li></ul><hr><h2 id="Ingress-1"><a href="#Ingress-1" class="headerlink" title="Ingress"></a>Ingress</h2><h3 id="為什麼一定需要-Ingress"><a href="#為什麼一定需要-Ingress" class="headerlink" title="為什麼一定需要 Ingress ?"></a>為什麼一定需要 Ingress ?</h3><p>每一個 LoadBalancer Service 都需要有自己的 IP，而 Ingress 只需要一個 IP。</p><p><img src="https://i.imgur.com/vaXiJZd.png"></p><p><strong>Ingress 是在 Layer 7 上面運作，所以可以提供比 Service 更多的功能。</strong></p><h3 id="Ingress-Controller"><a href="#Ingress-Controller" class="headerlink" title="Ingress Controller"></a>Ingress Controller</h3><p>必須記得 K8s cluster 中必須要有 Ingress controller 才可以讓 Ingress 正常運作。不同的 K8s 環境在 controller 實作上也不同。</p><h3 id="創建-Ingress"><a href="#創建-Ingress" class="headerlink" title="創建 Ingress"></a>創建 Ingress</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubia</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">kubia.example.com</span></span><br><span class="line">    <span class="attr">http:</span> </span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/</span> </span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">serviceName:</span> <span class="string">kubia-nodeport</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="number">80</span></span><br><span class="line">  <span class="comment">#     - path: /foo</span></span><br><span class="line">  <span class="comment">#       backend:</span></span><br><span class="line">  <span class="comment">#         serviceName: bar</span></span><br><span class="line">  <span class="comment">#         servicePort: 80</span></span><br><span class="line">  <span class="comment"># - host: bar.example.com </span></span><br><span class="line">  <span class="comment">#     http:</span></span><br><span class="line">  <span class="comment">#       paths:</span></span><br><span class="line">  <span class="comment">#         - path: /</span></span><br><span class="line">  <span class="comment">#           backend:</span></span><br><span class="line">  <span class="comment">#             serviceName: bar</span></span><br><span class="line">  <span class="comment">#             servicePort: 80</span></span><br></pre></td></tr></table></figure><!-- :::warning> FIXEME: 1.幹嘛還需要 ingress 如果有 nodeport 了 2.GKE 還需要用 ingress 嗎在 GKE 中，要求 service 必須為 NodePort ，但在 k8s 系統中是沒有這個要求的::: --><p>一個 client 向 K8s cluster 請求的基本流程</p><!-- ![](https://i.imgur.com/g8e8Gft.png) --><img src="https://i.imgur.com/g8e8Gft.png" width="800" height="400" />]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Microservice </tag>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes 筆記 - Component 1</title>
      <link href="2021/01/09/Container%20%E7%AE%A1%E7%90%86%20(%E7%AD%86%E8%A8%98%20%E4%BA%8C)%20-%20Kubernetes/"/>
      <url>2021/01/09/Container%20%E7%AE%A1%E7%90%86%20(%E7%AD%86%E8%A8%98%20%E4%BA%8C)%20-%20Kubernetes/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上篇提到使用 Kubernetes 情境的前因後果以及它的基礎架構。這次本篇主要在紀錄 Kubernetes 常用的部分元件的介紹和如何使用：</p><ul><li>Pod</li><li>Label</li><li>ReplicaSet</li><li>DaemonSet</li></ul><span id="more"></span><h1 id="kubernetes-Component"><a href="#kubernetes-Component" class="headerlink" title="kubernetes Component"></a>kubernetes Component</h1><h2 id="k8s-物件的概念"><a href="#k8s-物件的概念" class="headerlink" title="k8s 物件的概念"></a>k8s 物件的概念</h2><p>k8s 常見的物件像是 <code>Pod</code>、<code>Service</code>、<code>deployment</code>、<code>ingress</code> 等等</p><p><strong>使用 Kubernetes API 時，是以 JSON 或 YAML 檔案來定義物件。</strong></p><!-- - 這些檔案不是由伺服器因應 query 的請求而返回，又或是作為請求 api 的一部分傳到伺服器上。 --><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># This&#x27;s a yaml file to describe the spec and state of Pod objects.</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">kubia-manual</span></span><br><span class="line">    <span class="attr">labels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">kubia</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">    <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">oliwave/kubia</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">kubia</span></span><br><span class="line">      <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8080</span></span><br><span class="line">        <span class="attr">protocol:</span> <span class="string">TCP</span></span><br></pre></td></tr></table></figure><h2 id="k8s-物件和-RESTful-API-的關係"><a href="#k8s-物件和-RESTful-API-的關係" class="headerlink" title="k8s 物件和 RESTful API 的關係"></a>k8s 物件和 RESTful API 的關係</h2><ul><li>任何資源在 k8s 當中都可以用 <strong>RESTful 的 <a href="https://dev.to/flippedcoding/what-is-the-difference-between-a-uri-and-a-url-4455">URI</a> 來表示</strong>。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;your-k8s.com&#x2F;api&#x2F;v1&#x2F;namespaces&#x2F;default&#x2F;pods&#x2F;my-pod</span><br></pre></td></tr></table></figure></li><li>這些資源在 k8s 當中都叫做 Kubernetes objects 。</li><li>每一個 kubernetes objects 都存在 <strong>唯一的 HTTP/HTTPS 路徑</strong>。</li></ul><p>取得 Kubernetes objects 最基本的 kubectl 指令是 <strong>get</strong> </p><blockquote><p>kubectl get &lt;resource-name&gt;</p></blockquote><p>列出在目前 namespaces 底下的所有資源，然而若想要取得特定資源</p><blockquote><p>kubectl get &lt;resource-name&gt; &lt;obj-name&gt;</p></blockquote><p>想要知道該物件的詳細資訊</p><blockquote><p>kubectl describe &lt;resource-name&gt; &lt;obj-name&gt;</p></blockquote><hr><h3 id="o-參數的意義"><a href="#o-參數的意義" class="headerlink" title="-o 參數的意義"></a>-o 參數的意義</h3><p>在預設的情況下， kubectl 的返回結果是 human-readable ，但這會導致許多詳細的資訊被省略掉。如果想要得到完整的 <strong>物件</strong> 可以加上 -o 參數並指定想要的格式</p><blockquote><p>-o json/yaml</p></blockquote><p>更進階的做法還可以從返回的物件中指定想要看到的 field</p><blockquote><p>kubectl get pods my-pod -o jsonpath –template={.status.podIP}</p></blockquote><hr><h3 id="Creating-Updating-物件"><a href="#Creating-Updating-物件" class="headerlink" title="Creating, Updating 物件"></a>Creating, Updating 物件</h3><h4 id="範例"><a href="#範例" class="headerlink" title="範例"></a>範例</h4><p>假設有一個簡單的物件在 <code>obj.yaml</code> 中定義好了。可以透過 kubectl 在 Kubernetes 中 <strong>創建和更新</strong> 該物件</p><blockquote><p>kubectl apply -f obj.yaml</p></blockquote><p><strong>每個物件會有 metadata 這個欄位，用以定義物件唯一的名字</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#...</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">inventory</span></span><br><span class="line"><span class="comment">#...</span></span><br></pre></td></tr></table></figure><h1 id="Namespaces"><a href="#Namespaces" class="headerlink" title="Namespaces"></a>Namespaces</h1><p>Kubernetes 支持由同一 physical cluster 支持的多個 virtual clusters。這些  virtual clusters 稱為 <strong>Namespaces</strong>。</p><p><img src="https://i.imgur.com/A16s2k9.png"></p><p>namespaces 提供了名稱範圍。資源名稱在名稱空間內必須唯一，但在各個名稱空間之間是不用的。namespaces 彼此是平行的關係，</p><p><strong>物件的名字在一個 namespace 底下是唯一的</strong></p><ul><li><code>namespaces</code> 用來組織在叢集中的 <strong>物件</strong></li><li>可以把每一個 <em><code>namespaces</code></em> 都想像成一個 <strong>資料夾</strong> 管理自己的 <strong>物件</strong></li><li><code>kubectl</code> 預設是和 <code>default namespaces</code> 互動</li><li>如果想列出叢集中所有的 <code>pods</code> ，可以用 <code>--all-namespaces</code> 作為參數</li><li>不同的使用者應該有不同的 <code>namespaces</code> ，也需要有權限的管理</li></ul><h4 id="創建-Namespace"><a href="#創建-Namespace" class="headerlink" title="創建 Namespace"></a>創建 Namespace</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Namespace</span> <span class="comment"># 資源的類型</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">custom-namespace</span> <span class="comment"># Namespace 的名字</span></span><br></pre></td></tr></table></figure><p>在不同的 <code>namespace</code> 創建資源</p><blockquote><p>kubectl create -f kubia-manual.yaml -n custom-namespace</p></blockquote><h1 id="Pods"><a href="#Pods" class="headerlink" title="Pods"></a>Pods</h1><h2 id="Pod-基本概念"><a href="#Pod-基本概念" class="headerlink" title="Pod 基本概念"></a>Pod 基本概念</h2><ol><li>K8s 將多個 container 變成一組單位 <code>Pod</code> (Pod 有一群鯨魚的意思)<!-- 2. Pod 代表一個在相同環境底下執行的 application containers 和 volume 的集合 **// rephrase** --></li><li>Pod 是 K8s 中可部署的最小單位，也就是所有在 Pod 裡的 containers 都運行在同一個 worker node 上面。</li><li><strong>每一個在 Pod 裡面的 container 都擁有自己的 cgroup ，但卻共用一定數量的 namespaces</strong></li><li>應用程式在同個 Pod 中共享同個 <code>Network</code> 、 <code>UTS</code> (hostname)、 <code>IPC</code> namespaces ，因此可以用 <code>http://localhost:\&lt;port_num&gt;</code> 來彼此溝通 (IPC)。相反的應用程式在不同的 Pod 是隔離的，所以有不同的 IP 、 hostname 等等。</li></ol><hr><h2 id="Container-的概念"><a href="#Container-的概念" class="headerlink" title="Container 的概念"></a>Container 的概念</h2><p>使用 Linux 的兩個技術</p><ul><li><strong>Namespaces</strong>  確保每一個 process 都是由自己的觀點去看整個系統 (files, processes, network interfaces, hostname, and so on) <strong>軟體</strong></li></ul><ul><li><strong>Cgroups</strong> 限制每一個 process 可以使用的資源 (CPU, memory, network bandwidth, and so on) <strong>硬體</strong></li></ul><p>有許多種 Namespaces 而每一種都是在隔離不同種的資源</p><hr><h2 id="Pod-IP"><a href="#Pod-IP" class="headerlink" title="Pod IP"></a>Pod IP</h2><p>對 K8s 來說，不管 Pod 在哪一個 Node 上都可以把它們想像成在同一個 LAN 底下。因此彼此是可以訪問對方的，這是透過 <strong>CNI</strong> (overlay network) 來實現的。</p><p><img src="https://i.imgur.com/uBwYrHV.png"></p><!-- **在同一個 Pod 底下的 containers 就像一台實體主機或虛擬機上跑一些 processes 一樣** --><h2 id="如何創建一個-Pod"><a href="#如何創建一個-Pod" class="headerlink" title="如何創建一個 Pod"></a>如何創建一個 Pod</h2><p>事實上可以透過 kubectl 用以下幾種 K8s 提供的方式來創造物件</p><ul><li><code>Imperative command</code> 立即指令（<strong>不建議使用</strong>）<ul><li><blockquote><p>kubectl run kuard –generator=run-pod/v1 –image=gcr.io/kuar-demo/kuard-amd64:blue</p></blockquote></li></ul></li><li><code>Declarative configuation</code> =&gt; <strong>撰寫 Pod manifest</strong><ul><li><blockquote><p>kubectl apply -f pod.yaml</p></blockquote></li></ul></li></ul><ol><li>撰寫簡易的 Pod Manifest</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kuard</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">gcr.io/kuar-demo/kuard-amd64:blue</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">kuard</span></span><br><span class="line">      <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8080</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">          <span class="attr">protocol:</span> <span class="string">TCP</span></span><br></pre></td></tr></table></figure><hr><h3 id="什麼是-Pod-Manifest"><a href="#什麼是-Pod-Manifest" class="headerlink" title="什麼是 Pod Manifest"></a>什麼是 Pod Manifest</h3><ul><li>Pod Manifest 就只是一個用 json 或 yaml 格式來描述 <strong>Pod 物件</strong> 的文字檔案</li><li>該文件描述 Pod 的 <strong>ideal state</strong> ，因此<strong>這是一種 declarative configuration 而不是 imperative configuration</strong></li><li>事實上撰寫 Pod Manifest (或其他 K8s 物件) 是比較推薦的<ul><li>當 source code 在維護</li><li>更容易閱讀</li></ul></li></ul><hr><ol start="2"><li><p>把撰寫好的 Pod Manifest 透過 kubectl 丟到 K8s API server</p><ul><li><blockquote><p>kubectl apply -f kuard-pod.yaml</p></blockquote></li></ul></li><li><p>K8s API server 會做兩件事:</p><ol><li>透過 <strong>Kube Scheduler</strong> 會決定要放在哪個 worker node 上。</li><li><strong>Kubelet</strong> 屆時會負責把相對應寫在 Pod manifest 裡的 container 都運行起來，並且監控。</li></ol></li></ol><p>以上都步驟都完成後，可以查看所有 Pod 的狀況</p><p><code>kubectl get pods</code></p><p><img src="https://i.imgur.com/i29gYZY.png"></p><p>或是檢查單一 Pod 的詳細資訊</p><p><code>kubectl describe pods kuard</code></p><!-- > FIEXME: 調整 header --><h2 id="終止-pod"><a href="#終止-pod" class="headerlink" title="終止 pod"></a>終止 pod</h2><p><code>kubectl delete pods kuard</code></p><p>:::info</p><h3 id="還有許多可以對-Pod-做的設定…"><a href="#還有許多可以對-Pod-做的設定…" class="headerlink" title="還有許多可以對 Pod 做的設定…"></a>還有許多可以對 Pod 做的設定…</h3><h4 id="Grace-Period"><a href="#Grace-Period" class="headerlink" title="Grace Period"></a>Grace Period</h4><p>事實上當我們刪除一個 Pod 時 K8s 會做以下事情</p><ol><li>讓 Pod 拒絕接收新的 request，並消化當前還有的 request</li><li>在預設時間 30 秒過後才把 Pod 刪除掉</li></ol><p>以上的 30 秒就是所謂的 <strong>Grace period</strong> ，這麼做是為了確保服務的<strong>可靠性</strong>。我們不希望有任何請求是因為要刪除 Pod 而無法回應到的</p><h4 id="Health-Check"><a href="#Health-Check" class="headerlink" title="Health Check"></a>Health Check</h4><p>最簡易的 health check 就是 <strong>process health check</strong> 。也就是直接判斷該程序是否還繼續執行著。但這會有一個很大的問題就是萬一程序進入 dead lock ，事實上該程序仍然運行的但是卻無法再提供服務了。</p><p>因此在 K8s 引進了幾種方法來解決</p><h5 id="Liveness-Probe"><a href="#Liveness-Probe" class="headerlink" title="Liveness Probe"></a>Liveness Probe</h5><p>也<strong>就是執行一個任務，如果通過了他就還健在</strong>。常見的就是發 http request 檢查在 Pod 裡的 container 是否健康～<br><br></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kuard</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">gcr.io/kuar-demo/kuard-amd64:blue</span> </span><br><span class="line">      <span class="attr">name:</span> <span class="string">kuard</span></span><br><span class="line">      <span class="attr">livenessProbe:</span></span><br><span class="line">        <span class="attr">httpGet:</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">/healthy</span> <span class="comment"># 測試該容器是否健康的請求</span></span><br><span class="line">          <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">        <span class="attr">initialDelaySeconds:</span> <span class="number">5</span> <span class="comment"># 在 Pod 被初始化後的 5 秒才開始測試</span></span><br><span class="line">        <span class="attr">timeoutSeconds:</span> <span class="number">1</span> <span class="comment"># 限時 1 秒回應</span></span><br><span class="line">        <span class="attr">periodSeconds:</span> <span class="number">10</span> <span class="comment"># 每 10 秒一次</span></span><br><span class="line">        <span class="attr">failureThreshold:</span> <span class="number">3</span> <span class="comment"># 超過三次失敗就重起該 container</span></span><br><span class="line">      <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8080</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">            <span class="attr">protocol:</span> <span class="string">TCP</span></span><br></pre></td></tr></table></figure><h5 id="Readiness-Probe"><a href="#Readiness-Probe" class="headerlink" title="Readiness Probe"></a>Readiness Probe</h5><p>readiness probe 和 liveness probe 最大的不一樣就是 liveness probe 確認應用程式是否正確執行，而它則是 <strong>檢查該應用程式是不是已經準備好可以開始服務了</strong>。</p><h5 id="其他的-K8s-所提供的-Health-Check"><a href="#其他的-K8s-所提供的-Health-Check" class="headerlink" title="其他的 K8s 所提供的 Health Check"></a>其他的 K8s 所提供的 Health Check</h5><p>除了 HTTP 以外，還有 <strong>tcpSocket health checks</strong> 或是讓容器執行一段 script 來檢查。這麼做是因為不是每一個服務都是 http-base appliction.</p><hr><hr><h5 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h5><p><strong>以下都是不建議直接使用 kubectl 去操作的</strong> (違反 declarative configuration 精神)</p><p>有更適當的工具或方法去完成這些任務。</p><ol><li>取得 Pod 的 Logs (fluentd and elasticsearch)</li><li>在 container 裡面執行指令</li><li>從 container 裡面複製檔案到外面，反之亦然</li></ol><hr><h4 id="Resource-Management"><a href="#Resource-Management" class="headerlink" title="Resource Management"></a>Resource Management</h4><p>Pod 在資源（cpu, mem, gpu）的請求上在 K8s 有兩種方式</p><ul><li><strong>minimum</strong> 該容器最少需要多少該種類型的資源 (情況允許，可以多給)</li><li><strong>limit</strong> 該容器最多可以擁有該種類型的資源</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kuard</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">gcr.io/kuar-demo/kuard-amd64:blue</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">kuard</span></span><br><span class="line">        <span class="attr">resources:</span></span><br><span class="line">          <span class="attr">requests:</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="string">&quot;500m&quot;</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">&quot;128Mi&quot;</span></span><br><span class="line">          <span class="attr">limits:</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="string">&quot;1000m&quot;</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">&quot;256Mi&quot;</span></span><br><span class="line">      <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8080</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">            <span class="attr">protocol:</span> <span class="string">TCP</span></span><br></pre></td></tr></table></figure><ol><li><strong>記住資源的請求是以 container 為單位，因為不同服務需要的資源種類和數量都不一樣</strong></li><li><strong>一個 Pod 所請求的資源就是其所有 containers 資源請求的總和</strong></li><li><strong>記憶體與 CPU 資源的分配不一樣，因為記憶體一旦分配給一個程序就不能再收回。因此當系統消耗完記憶體的資源時，就會把取得過多的 contaienr 重啟以達重新分配記憶體資源</strong></li></ol><h4 id="在-Pod-中不同類型的-volume"><a href="#在-Pod-中不同類型的-volume" class="headerlink" title="在 Pod 中不同類型的 volume"></a>在 Pod 中不同類型的 volume</h4><ul><li>生命週期與 Pod 相同的 volume (<strong>emptyDir</strong>)<ul><li>For Communication/synchronization <ul><li>容器間可以共用一些資料</li></ul></li><li>For Cache<ul><li>有時容器需要或被重啟，那就可以緩衝一些運算昂貴的資料</li></ul></li></ul></li><li>長期維持的 Persistent volume Persistent<ul><li>不管是 private 或 public 的 provider ， k8s 都有提供 api</li><li>e.g. NFS, iSCSI, Amazon’s Elastic Block Store, Azure’s Files and Disk Storage,  Google’s Persistent Disk <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&quot;kuard-data&quot;</span></span><br><span class="line">    <span class="attr">nfs:</span></span><br><span class="line">      <span class="attr">server:</span> <span class="string">my.nfs.server.local</span> </span><br><span class="line">      <span class="attr">path:</span> <span class="string">&quot;/exports&quot;</span></span><br></pre></td></tr></table></figure></li><li>Mounting the host filesystem (hostPath)<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kuard</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&quot;kuard-data&quot;</span> </span><br><span class="line">      <span class="attr">hostPath:</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">&quot;/var/lib/kuard&quot;</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">gcr.io/kuar-demo/kuard-amd64:blue</span> </span><br><span class="line">      <span class="attr">name:</span> <span class="string">kuard</span></span><br><span class="line">      <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">&quot;/data&quot;</span> </span><br><span class="line">          <span class="attr">name:</span> <span class="string">&quot;kuard-data&quot;</span></span><br><span class="line">      <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8080</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">          <span class="attr">protocol:</span> <span class="string">TCP</span>      </span><br></pre></td></tr></table></figure></li></ul></li></ul><p><em>不像 docker ，沒有簡單的方法～</em></p><h1 id="Labels"><a href="#Labels" class="headerlink" title="Labels"></a>Labels</h1><ul><li>Labels 是 <strong>鍵值對</strong></li><li>Labels 提供了為 <strong>物件分組</strong> 的基礎（該物件可以是 pod, replicaSet …）</li></ul><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>Labels 提供一群物件可被識別的標記</strong>，這為之後分組、操作、查看等動作帶來方便。</p><p>在 K8s 中物件要尋找或參考到其他物件的時候就需要用到 selector 。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ReplicaSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubia</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span> <span class="comment"># ReplicaSet 用 label 來尋找它管理的物件</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">template:</span> <span class="comment"># PodTemplate </span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span> <span class="comment"># 將 pod 貼上 `app: test` 這個 label</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">test</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">kubia</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">luksa/kubia</span></span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/mSLyrq7.png" width="500" height="500" /></br></p><hr><p><code>Selector</code> 底下分兩種方式來參考到含有該 label 的物件:</p><ol><li><code>matchLabels</code> 和 <code>matchExpressions</code><ul><li><strong>只有 <code>Job</code>、<code>Deployment</code>、<code>ReplicaSet</code> 還有 <code>DaemonSet</code> 有支援</strong><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">selector:</span></span><br><span class="line">  <span class="attr">matchLabels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">tier:</span> <span class="string">frontend</span></span><br><span class="line"> <span class="comment"># or</span></span><br><span class="line"> <span class="comment">#matchExpressions:</span></span><br><span class="line"> <span class="comment">#- key: app # 鍵 必須為 &#x27;app&#x27;</span></span><br><span class="line"> <span class="comment">#  operator: In # 值 必須為 &#x27;kubia&#x27;</span></span><br><span class="line"> <span class="comment">#  values:</span></span><br><span class="line"> <span class="comment">#    - kubia</span></span><br></pre></td></tr></table></figure></li></ul></li><li>什麼都不加，直接放 label<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">selector:</span></span><br><span class="line">  <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">tier:</span> <span class="string">frontend</span></span><br></pre></td></tr></table></figure></li></ol><p><a href="https://medium.com/@zwhitchcox/matchlabels-labels-and-selectors-explained-in-detail-for-beginners-d421bdd05362">(matchLabels, labels, and selectors 差別)</a></p><hr><h1 id="ReplicaSet-amp-DaemonSet"><a href="#ReplicaSet-amp-DaemonSet" class="headerlink" title="ReplicaSet &amp; DaemonSet"></a>ReplicaSet &amp; DaemonSet</h1><!-- ![](https://i.imgur.com/7cq15KY.png) --><img src="https://i.imgur.com/7cq15KY.png" width="800" height="400" /><ul><li><p><strong>RS</strong> 定義一個 Pod 數量讓他們隨機散佈在 K8s cluster 中</p></li><li><p><strong>DS</strong> <strong>特殊需求</strong> ，要讓 cluster 中的每個 worker node 都有一個該服務的 Pod 。</p><ul><li>例如，像是 log collector 或是 memory monitor 的程式需要在每個節點上。</li><li>在 K8s 系統中 kube-proxy Pod 也是運行在每一個節點上。</li></ul></li></ul><h2 id="ReplicaSet"><a href="#ReplicaSet" class="headerlink" title="ReplicaSet"></a>ReplicaSet</h2><ol><li>通常不會直接使用 ReplicaSet 而是用更高層次的 Deployment<!-- 2. 基本上兩者功能都相同，但是在 label selector 上 ReplicaSet **可以同時比較兩個 labels 以上，還有直接判斷是否有該 key 而不管它的 value (e.g. env=\*)** --></li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ReplicaSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubia</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">kubia</span></span><br><span class="line">    <span class="comment">#matchExpressions:</span></span><br><span class="line">    <span class="comment">#- key: app # 鍵 必須為 &#x27;app&#x27;</span></span><br><span class="line">    <span class="comment">#  operator: In # 值 必須為 &#x27;kubia&#x27;</span></span><br><span class="line">    <span class="comment">#  values:</span></span><br><span class="line">    <span class="comment">#    - kubia</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">kubia</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">kubia</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">luksa/kubia</span></span><br></pre></td></tr></table></figure><p>詳情可見 <a href="https://hackmd.io/exfgC8MzSfqKsJgkWIpkJA?both#Labels-Selectors">label selector</a></p><h2 id="DaemonSet"><a href="#DaemonSet" class="headerlink" title="DaemonSet"></a>DaemonSet</h2><p><strong>DS 只會在每一個 Node 上執行一個 Pod</strong></p><p>因此 DaemonSet 不需要透過 K8s scheduler 來安排 Pod 在哪個節點上</p><h3 id="將-Pod-部署到特定的節點上"><a href="#將-Pod-部署到特定的節點上" class="headerlink" title="將 Pod 部署到特定的節點上"></a>將 Pod 部署到特定的節點上</h3><img src="https://i.imgur.com/ksxUhIn.png" width="800" height="400" /><!-- ![](https://i.imgur.com/ksxUhIn.png) --><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">DaemonSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ssd-monitor</span> </span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">ssd-monitor</span> <span class="comment"># 管理 label 為 `app:ssd-monitor` 的 Pod</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">ssd-monitor</span> </span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">nodeSelector:</span> <span class="comment"># PodSpec 定義的 field</span></span><br><span class="line">        <span class="attr">disk:</span> <span class="string">ssd</span> <span class="comment"># 把 Pod 部署到有 ssd 的節點上</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">main</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">luksa/ssd-monitor</span></span><br></pre></td></tr></table></figure><hr><ul><li><em>如果 nodeSelector 沒有成功找到符合的節點，就不會創建 Pod</em></li><li><em>刪除 RS DS 都會連帶刪除旗下的 Pods</em></li></ul><p>daemonset 也可以用 label selector 部署 pod 到特定的 node 上</p><hr>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Microservice </tag>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes 筆記 - Monolithic to Microservice 0</title>
      <link href="2020/11/09/Container%20%E7%AE%A1%E7%90%86%20(%E4%B8%80)%20-%20Monolithic%20to%20Microservice/"/>
      <url>2020/11/09/Container%20%E7%AE%A1%E7%90%86%20(%E4%B8%80)%20-%20Monolithic%20to%20Microservice/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在玩轉 Kubernetes 這個炫砲的技術之前，我們必須要先瞭解它到底在解決什麼樣的問題以及整個來龍去脈。該文章主要先探討 Monlithic 作為歷史背景下常用的開發模式，一直到使用 Microservice 時遇到的處境以及相對應工具的搭配，來呈現在應用程式微服務化的情境底下如何管理大量的微服務。系列文章是 <a href="https://www.tenlong.com.tw/products/9781617293726">Kubernetes in action</a> 讀後的筆記文。</p><span id="more"></span><h3 id="Monolithic-的缺點"><a href="#Monolithic-的缺點" class="headerlink" title="Monolithic 的缺點"></a>Monolithic 的缺點</h3><ol><li>隨時間而變肥大且複雜，軟體難以重構。在除錯時也難以尋找。</li><li>不能依據不同服務的流量需求來 <strong>水平擴展</strong> ，而是一次部署整體支應用程式造成不必要的資源成本增加。</li></ol><h3 id="Microservice-的優點"><a href="#Microservice-的優點" class="headerlink" title="Microservice 的優點"></a>Microservice 的優點</h3><ol><li>開發上的可以做到良好的<strong>解隅 (Decouple)</strong></li><li>擁有水平擴展的能力 (依然需要看情境)</li><li>不同的微服務可以獨立維護部署</li></ol><img src="https://i.imgur.com/enSwKWw.png" width="800" height="400" /><img src="https://i.imgur.com/fSUyZRB.png" width="800" height="400" /><h2 id="困難點"><a href="#困難點" class="headerlink" title="困難點"></a>困難點</h2><ul><li><p>😂 重新抽象軟體架構</p></li><li><p>😂 <strong>API 要變成 stateless</strong> (*註解ㄧ)</p></li><li><p>😍 由於系統變得龐大且複雜，所以在除錯上會更加困難 <a href="https://zipkin.io/">Zipkin</a></p></li><li><p>😍😎 當有大量的微服務 <strong>相互依賴</strong> 時會讓你要去決定誰去要一起被部署</p></li><li><p>😎 微服務造成環境的多樣性更高，在開發和部署環境上更不容易維護</p></li><li><p>😎 環境需求的不同，程式想要不同版本的 shared libs</p></li></ul><p>註解一：</p><ol><li>當你的服務不需要在內部維持請求之間的狀態時就是 <strong>stateless service</strong> ，反之就是 <strong>stateful service</strong> (<strong>需要開 sticky session</strong>)。</li><li>微服務應該將狀態資訊儲存在外部而非內部，這才有利於服務的擴展。</li></ol><p><a href="https://stackoverflow.com/questions/58696684/stateless-vs-stateful-microservices">stateful vs stateless</a></p><h2 id="解決"><a href="#解決" class="headerlink" title="解決"></a>解決</h2><ul><li><p>😂 依賴軟體團隊的經驗設計</p></li><li><p>😍 服務的<a href="https://www.fiorano.com/blogs/microservices">顆粒度(Granularity)</a>應該以獨立的業務邏輯來解決之間因 <strong>相互依賴</strong> 導致 <strong>除錯困難</strong> 的問題</p></li><li><p>😎 <strong>We ease the pain with the help of docker and kubernetes.</strong></p></li></ul><h1 id="介紹"><a href="#介紹" class="headerlink" title="介紹"></a>介紹</h1><p><strong>因應大量容器部署管理的困難，所以才需要有一個容器管理工具來解決</strong> (e.g. 某公司測試用 8000 個 container)</p><h2 id="Container-management-solutions"><a href="#Container-management-solutions" class="headerlink" title="Container management solutions"></a>Container management solutions</h2><ul><li><strong>docker-compose</strong> <ul><li>適用在 <strong>單節點</strong> 的環境上，可以快速部署多個容器。</li></ul></li><li><strong>openshift</strong> <ul><li><strong>now base on kubernetes</strong></li><li>red hat cloud 較不有名<img src="https://i.imgur.com/JegIerL.png" width="450" height="450" /></li></ul></li><li><strong>kubernetes</strong><ul><li>在 public cloud 得到最完整的支援</li><li>儼然成為 Container Management 的標準 </li></ul></li><li><strong>minikube</strong><ul><li>local 的單節點 k8s。<strong>適合拿來練習</strong></li></ul></li><li><strong>k3s</strong> (閹割)<ul><li>沒有 add-ons ，不夠彈性</li></ul></li><li><strong>microk8s</strong><ul><li>有 add-ons ，可彈性抽換不同 component</li></ul></li></ul><h2 id="What’s-the-Kubernetes"><a href="#What’s-the-Kubernetes" class="headerlink" title="What’s the Kubernetes?"></a>What’s the Kubernetes?</h2><h3 id="歷史"><a href="#歷史" class="headerlink" title="歷史"></a>歷史</h3><ol><li>Kubernetes（又稱為 k8s）是一個開放原始碼的 <strong>容器編排管理系統 container orchestrator</strong>，用於自動化應用程序的部署，擴展和管理。</li><li>Google 於 2014 年中首次宣布 Kubernetes ，現由 <a href="https://www.cncf.io/">Cloud Native Computing Foundation (CNCF)</a> 負責維護。</li><li>原以 C++ 編寫，後以 Golang 重構。</li><li>發音 koo ～ ber ～ natis，又稱作 <strong>k8s</strong>。</li></ol><h3 id="叢集架構"><a href="#叢集架構" class="headerlink" title="叢集架構"></a>叢集架構</h3><!-- ![](https://i.imgur.com/g8e8Gft.png) --><img src="https://i.imgur.com/g8e8Gft.png" width="800" height="400" /><ol><li><strong>Pod</strong> 最基本的部署單位。</li><li><strong>Service</strong> 代表一組功能相同的 Pods 群體。訪問 Service 時會自動 load balance 到該群體底下任意的 Pod 上。</li><li><strong>Label</strong> 可以將任意物件 <strong>貼上標籤</strong> ，方便將物件進行分組還有分配任務</li><li><strong>Ingress</strong> 用於管理從外部對叢集中的 <strong>Service</strong> 進行訪問（HTTP, HTTPS）。必須部署到 master node 上面。</li></ol><h3 id="系統元件"><a href="#系統元件" class="headerlink" title="系統元件"></a>系統元件</h3><!-- > FIXME: ingress service 在哪兒？ --><img src="https://i.imgur.com/zpnOfVC.png" width="800" height="450" /><ul><li><strong>master node</strong> : 負責管理和控制所有 <strong>worker node</strong> 的主機。</li><li><strong>Worker node</strong> : 運行微服務的主機。</li><li><strong>API server</strong> : 提供 Kubernetes API ，讓使用者可以透過它管理和設定整個系統。</li><li><strong>etcd</strong> : 儲存整個 k8s 叢集中物件的規格。</li><li><strong>Scheduler</strong> : 負責決定 Pod 要部署到哪一個節點上。</li><li><strong>Kubelets</strong> : <strong>視為每個節點的大腦</strong>。<ul><li>作為 master node 和 worker node 溝通的媒介。</li><li>負責管理 Pod，包括在 Pod 發生故障時創建新的 Pod。</li></ul></li><li><strong>cAdvisor</strong> : 搜集該節點上所有資源的資訊，透過 kubelet 隨時回報給 master node。</li><li><strong>Kube-Proxy</strong> : 維護節點上的網絡規則。負責網路流量的傳送。</li></ul><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul><li><p><strong>Velocity 速度</strong></p><ul><li>可達成短時間多次的不停機更新。<br><img src="https://i.imgur.com/v6vg4AW.jpg" width="550" height="325" /></br></li></ul></li><li><p><strong>Immutability 不變性</strong></p><ul><li>當軟體版本更新時<ul><li>✅ (<strong>immutable</strong>) 重新 <strong>build</strong> 一個更新的 <strong>image</strong> </li><li>❌ (<strong>mutable</strong>) 進入 <strong>container</strong> 更新 </li></ul></li></ul></li><li><p><strong>Declarative configuration 宣告式設定</strong></p><ul><li><strong>命令式命令 (imperative commands)</strong> 定義了 <strong>行為</strong> 。「執行Ａ，執行Ｂ，然後再執行Ｃ…」</li><li><strong>宣告式設定 (declarartive configurations)</strong> 定義了 <strong>狀態</strong> 。「我需要三個Ａ程式」</li></ul></li><li><p><strong>Self-healing 自我修復</strong></p><ul><li>隨時維護當前所需的狀態設定。</li></ul></li><li><p><strong>Scalability 擴展性</strong></p><ul><li>通過新增或刪除 Pod 輕鬆地上下擴展服務的工作負載。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Microservice </tag>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter 筆記(三) - 動畫與頁面路由</title>
      <link href="2020/09/09/Flutter-%E7%AD%86%E8%A8%98-%E4%BA%8C-%E9%80%B2%E9%9A%8E%E8%AA%8D%E8%AD%98/"/>
      <url>2020/09/09/Flutter-%E7%AD%86%E8%A8%98-%E4%BA%8C-%E9%80%B2%E9%9A%8E%E8%AA%8D%E8%AD%98/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本篇記錄了 Flutter 動畫機制的介紹以及有別其他 UI 針對動畫所發展出的一套狀態管理機制。最後也會探討到頁面路由的各項管理機制的差別。 </p><span id="more"></span><h1 id="Animation-In-Flutter"><a href="#Animation-In-Flutter" class="headerlink" title="Animation In Flutter"></a>Animation In Flutter</h1><h2 id="第一個動畫"><a href="#第一個動畫" class="headerlink" title="第一個動畫"></a>第一個動畫</h2><img src="https://i.imgur.com/wYRfhhb.png" width="500" height="500" /><ul><li>讓箱子的兩邊可以拍打</li><li>停止拍打時, 貓咪垂直往上跑出</li></ul><h2 id="動畫的各種Widget"><a href="#動畫的各種Widget" class="headerlink" title="動畫的各種Widget"></a>動畫的各種Widget</h2><img src="https://i.imgur.com/05OcnwU.jpg" width="700" height="400" /><p><code>Animation</code> <code>AnimationController</code> <code>Tween</code> <code>AnimatedBuilder</code> 是四個不同的組件分別執行不同的功能:</p><ol><li><p><strong>AnimatedBuilder</strong></p><ul><li>最常被用到的 widget</li><li>需要一個 <code>Animation</code> widget 實體和一個 <code>builder function</code></li><li>當每一次動畫發生改變時就調用 <code>builder function</code> 來更新在我們裝置上的 widget</li><li>該 widget 非常類似 <code>StreamBuilder</code></li></ul></li><li><p><strong>Animation</strong></p><ul><li>記錄”要動畫”的屬性的當前<strong>值</strong> </li><li>記錄動畫的狀態(正在跑, 已停止, 等等)</li></ul></li><li><p><strong>AnimationController</strong></p><ul><li>主要負責則<strong>控制動畫的狀態</strong> (開始, 暫停, 重新…)</li><li>記錄動畫要執行多久 duration of animation</li><li>通知 <code>Animation</code> 的<strong>值</strong>需要改變 (<strong><a href="https://docs.flutter.io/flutter/scheduler/TickerProvider-class.html">TickerProvider</a></strong>)</li></ul></li><li><p><strong>Tween</strong> - beTween</p><ul><li>描述動畫的<strong>值</strong>所會跨越的範圍      </li></ul></li></ol><h2 id="Why-StatefulWidget-For-Animation"><a href="#Why-StatefulWidget-For-Animation" class="headerlink" title="Why StatefulWidget For Animation ?"></a>Why StatefulWidget For Animation ?</h2><hr><p> <strong>為什麼用StatefulWidget而不是用Bloc來管理widget的狀態和數據呢？</strong></p><ol><li><p><code>Bloc</code> 就之前的學習經驗上我們可以得知他的用途 : </p><ul><li><strong>讓不同的 widget 共享相同的資訊</strong></li><li>集體管理各個 widget 所需用到的數據和狀態以及業務邏輯使其與介面分離</li></ul></li><li><p><code>Animation</code> 當然可以使用 <code>Bloc</code> 來操作但為啥沒有 :</p><ul><li>動畫基本上他所需要的狀態和數據並不會影響其 widget</li><li><code>Bloc</code> 需要大量的模板程式碼會過於複雜, 對於不需要使用到它上述功能的 widget 來說反而更不方便</li><li><strong><code>StatefulWidget</code> 在操作動畫上會更為靈活和彈性好多</strong> (他只在乎當下該 widget 的 state)</li></ul></li></ol><hr><hr><p><strong>重新渲染的盲點</strong></p><ul><li><p><strong>動畫</strong></p><ul><li>用 <code>State</code> 來儲存不想隨著 widget 更新而丟棄的數據. 在整個 widget 生命中期間持續存在被使用著</li><li><strong>不用 <code>setState()</code> 來重新渲染 widget , 而是用 <code>AnimatedBuilder</code> 來重新渲染畫面</strong></li></ul></li><li><p><strong>一般使用</strong></p><ul><li>用 <code>Bloc</code> 來儲存各個 widget 所可能交互使用的數據, 以 <code>StreamController</code> 的概念加以維護控制</li><li><strong>因為不用 <code>State</code> 來做, 所以 widget 都用 <code>StatelessWidget</code> 就行了. 至於重新渲染方面就交給 <code>StreamBuilder</code> 來達成</strong></li></ul></li><li><p><strong>結論</strong></p><ul><li><em>重新渲染方面都交由 XxBuilder 來完成就行了</em></li></ul></li></ul><hr><h2 id="Animation-Development-Details"><a href="#Animation-Development-Details" class="headerlink" title="Animation Development Details"></a>Animation Development Details</h2><p><strong>動畫實例開發：</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter/material.dart&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;../widgets/cat.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Home</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _HomeState createState() =&gt; _HomeState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TickerProvider 給widget外面的世界一個識別證可以進來該widget</span></span><br><span class="line"><span class="comment">//, 為了通知AnimationController更新Animation</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_HomeState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">Home</span>&gt; </span></span><br><span class="line"><span class="class">                    <span class="title">with</span> <span class="title">TickerProviderStateMixin</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 這兩個變數會在widget整個生命中持續存在被持有</span></span><br><span class="line">  Animation&lt;<span class="built_in">double</span>&gt; catAnimation;</span><br><span class="line">  AnimationController catController;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1. 當State第一次被創建時會調用這個方法</span></span><br><span class="line">  <span class="comment">// 2. 只有繼承State的widget才有該方法</span></span><br><span class="line">  <span class="comment">// 3. 用來初始化實體變數</span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> implement initState</span></span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line"></span><br><span class="line">    catController = AnimationController(</span><br><span class="line">      duration: <span class="built_in">Duration</span>(seconds: <span class="number">1</span>), <span class="comment">// 該動畫會持續多久</span></span><br><span class="line">      vsync: <span class="keyword">this</span>, <span class="comment">// 代表嵌入TickerProvider到當前運行的widget實體</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    catAnimation = Tween(begin: <span class="number">0.0</span>, end: <span class="number">200.0</span>)</span><br><span class="line">        .animate(CurvedAnimation(</span><br><span class="line">          <span class="comment">// 該widget用來描述, 動畫數值從begin到end的比率有多快</span></span><br><span class="line">          parent: catController,</span><br><span class="line">          curve: Curves.easeIn,</span><br><span class="line">        ));</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">&#x27;Animation!&#x27;</span>),</span><br><span class="line">      ),</span><br><span class="line">      body: GestureDetector( <span class="comment">// 手勢偵測器</span></span><br><span class="line">        child: buildAnimation(), <span class="comment">// 偵測該子widget上使用者的手勢</span></span><br><span class="line">        onTap: onTap,</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Widget buildAnimation() &#123;</span><br><span class="line">    <span class="keyword">return</span> AnimatedBuilder(</span><br><span class="line">      animation: catAnimation,</span><br><span class="line">      child: Cat(), <span class="comment">// a really expensive widget to create</span></span><br><span class="line">      builder: (context, child) &#123;</span><br><span class="line">        <span class="keyword">return</span> Container(</span><br><span class="line">          <span class="comment">// inexpensive widget to create</span></span><br><span class="line">          child: child,</span><br><span class="line">          margin: EdgeInsets.only(top: catAnimation.value),</span><br><span class="line">        );</span><br><span class="line">      &#125;,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> onTap() &#123;</span><br><span class="line">    catController.forward();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>AnimatedBuilder</strong></p><ul><li><img src="https://i.imgur.com/VssG3cJ.png" width="600" height="300" /></li><li><p><em>兩個問題的探討</em> : </p><ol><li><p><strong>對 <code>XxBuilder</code> 的概念是什麼？ - 就 StreamBuilder 經驗來看</strong></p><ul><li>監控隨時會改變的東西 <code>Stream/Animation</code></li><li>一有改變就呼叫 <code>builder function</code> , 裡面返回新的要重新渲染的 Widget</li></ul></li><li><p><strong>為什麼需要 <code>child</code> 屬性？？</strong></p><ul><li><code>child</code> 負責持有重新渲染會造成很大負擔的 widget 的參考</li><li>在調用 <code>builder function</code> 時將 <code>child</code> 參考傳入參數. </li><li>在 <code>builder function</code> 去更新重建不昂貴的 widget</li></ul></li></ol></li></ul><p><strong>AnimationController</strong></p><ul><li><img src="https://i.imgur.com/2m3Cr4N.png"></li><li><strong>vsync: this 的意義？？ - 動畫運行的機制</strong><ol><li><code>StreamController</code> 設定完動畫的持續時間並不會無中生有的去<strong>驅動</strong>提醒動畫要改變數值或是要更新了</li><li><code>vsync: this</code> 在這裡的用途就是讓當前已經mixin <code>TickerProviderStateMixin</code>  的 widget 擁有<code>TickerProvider</code>, 再用 <code>this</code> 傳入 <code>AnimationController</code>. </li><li><code>TickerProvider</code> 會提供 <code>Ticker</code> , 可以想像成一個 <strong>鉤子hook</strong>, 他用來提供該 Widget(這裡是Home widget)以外的世界,一個可以進入該 widget 來通知需要更新 frame 的管道</li></ol></li></ul><p><strong>Tween &amp; Animation</strong></p><ul><li><img src="https://i.imgur.com/BvpvfiD.png"></li><li><code>Tween</code> : 可以看成是製作動畫的前置作業<ul><li>設定動畫數值的範圍 - <code>begin</code> &amp; <code>end</code></li></ul></li><li><code>Aniamtion</code> : 描述動畫的主體<ul><li>從 <code>begin</code> —–&gt; <code>end</code> 變動的比率有多快</li></ul></li></ul><hr><h4 id="Flutter-Animation-的小小觀察"><a href="#Flutter-Animation-的小小觀察" class="headerlink" title="Flutter Animation 的小小觀察"></a><em>Flutter Animation 的小小觀察</em></h4><ol><li>從頭至尾, 所有的動畫程式碼都圍繞在處理<strong>數值</strong>變動</li><li>Flutter 動畫並不關心也不知道動畫最後會應用到哪一個 Widget</li><li>動畫並不會去綁定特定 Widget , 反之亦然. </li><li>動畫和 widget 沒有任何關係</li></ol><hr><h1 id="API-Performing-Strategy"><a href="#API-Performing-Strategy" class="headerlink" title="API Performing Strategy"></a>API Performing Strategy</h1><h2 id="Fetching-data"><a href="#Fetching-data" class="headerlink" title="Fetching data"></a>Fetching data</h2><p><img src="https://i.imgur.com/BIpYpI0.png"></p><ul><li><code>Repository</code> <ol><li>當作 App 與資料來源中間的<strong>媒介</strong></li><li>UI 不能也不需要跟資料來源溝通</li></ol></li></ul><h2 id="Architecture-of-the-App"><a href="#Architecture-of-the-App" class="headerlink" title="Architecture of the App"></a>Architecture of the App</h2><img src="https://i.imgur.com/jNVWpZi.png" width="500" height="500" /><h2 id="Testing-with-dart"><a href="#Testing-with-dart" class="headerlink" title="Testing with dart"></a>Testing with dart</h2><img src="https://i.imgur.com/aG9ZMNI.png" width="700" height="400" /><p><strong>Testing 的用途</strong></p><ul><li><p>如果檔案後面沒有後綴 <code>_test</code> 測試時會找不到</p></li><li><p>每一個 test file 都有一個 <code>main()</code></p></li><li><p>都是獨立的程式</p></li><li><p><strong>方便進行單元測試, 不用啟動整個 app</strong></p></li></ul><hr><p><em><strong>對於網路的測試</strong></em></p><p><strong>有兩個理由為什麼不直接真實的 http request :</strong></p><ol><li>做單元測試本來就是耗時的工作, 如果加上網路的延遲會造成極大的負擔</li><li>真實 API 的異動是很大的. 往往會造成測試的不方便</li></ol><p><strong>解法 :</strong></p><ul><li><em>使用 <code>http</code> 套件裡面的 <code>testing.dart</code>, 裡面有模仿 http request 的功能</em></li><li><img src="https://i.imgur.com/FmCfI2M.png" width="700" height="400" /></li></ul><hr><h2 id="Offline-Data-Storage-In-Flutter"><a href="#Offline-Data-Storage-In-Flutter" class="headerlink" title="Offline Data Storage In Flutter"></a>Offline Data Storage In Flutter</h2><img src="https://i.imgur.com/xMRUiiw.png" width="700" height="400" /><p>(<a href="https://github.com/OliverWangWei/HN">my project structure</a>)</p><ol><li><p><em><strong>init</strong></em> </p><ul><li>該方法用來對 DB 進行初始會以及連結的設定</li><li><strong>通常初始化都在建構子</strong></li><li>跟 DB 有關的都是<code>異步 asynchronous</code></li><li>建構子不能有異步</li></ul></li><li><p><em><strong>fetchItem</strong></em></p><ul><li><img src="https://i.imgur.com/ykH79Ld.png" width="700" height="400" /></li><li><p><code>query</code> 返回的類型一定是 <code>List&lt;Map&lt;String, dynamic&gt;&gt;</code></p></li></ul></li></ol><h2 id="Refactor-Repository-By-Abstract-Class"><a href="#Refactor-Repository-By-Abstract-Class" class="headerlink" title="Refactor Repository By Abstract Class"></a>Refactor Repository By Abstract Class</h2><hr><p><strong>重構概述</strong></p><p>利用<code>abstract class</code>來重構現有App的架構</p><hr><h4 id="為什麼要用抽象類別在-Dart-中"><a href="#為什麼要用抽象類別在-Dart-中" class="headerlink" title="為什麼要用抽象類別在 Dart 中"></a>為什麼要用抽象類別在 Dart 中</h4><ol><li>抽象出不同類之間共同的特性變成另一個類</li><li>增加程式碼的重用率</li></ol><h1 id="Navigation-In-Flutter"><a href="#Navigation-In-Flutter" class="headerlink" title="Navigation In Flutter"></a>Navigation In Flutter</h1><hr><p><strong>Navigation 概述</strong></p><ul><li><strong>主要負責決定要在裝置的螢幕上顯示甚麼頁面</strong></li></ul><ul><li><p><strong>route 就是 screen</strong></p></li><li><p><strong>route 是由 Navigator 所控制的</strong></p></li><li><p><strong>Navigator 提供管理 route 物件堆疊的方法</strong></p></li><li><p><strong>當 <code>new</code> 一個 <code>MaterialApp</code> 時, <code>Navigation</code> 就被實例化供我們使用了</strong></p></li></ul><hr><h2 id="設定初始頁面"><a href="#設定初始頁面" class="headerlink" title="設定初始頁面"></a>設定初始頁面</h2><p>設定初始頁面的方式</p><ol><li><p><code>home</code> 屬性: <strong>物件（Widget)</strong></p> <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  runApp(MaterialApp(</span><br><span class="line">    home: MyHomePage(),</span><br><span class="line">          .</span><br><span class="line">          .</span><br><span class="line">          .</span><br><span class="line">  ));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>不一定要設定 <code>routes</code> 和 <code>onGenerateRoute</code> 屬性（通常會需要，因為隨著 App 複雜性的增高，統一管理頁面是比較恰當的) ; 反之，<code>initialRoute</code> 就必須要設定</li></ul></li><li><p><code>initialRoute</code> 屬性: <strong>路徑</strong></p> <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  runApp(MaterialApp(</span><br><span class="line">    initialRoute: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">    routes: &lt;<span class="built_in">String</span>, WidgetBuilder&gt;&#123;</span><br><span class="line">        <span class="string">&#x27;/&#x27;</span>: (context) =&gt; HomePage(),</span><br><span class="line">        <span class="string">&#x27;/second&#x27;</span>: (context) =&gt; SecondHome()</span><br><span class="line">    &#125;</span><br><span class="line">          .</span><br><span class="line">          .</span><br><span class="line">          .</span><br><span class="line">  ));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果使用 <code>initialRoute</code> 就必須要設定 <code>routes</code> 或是 <code>onGenerateRoute</code> 屬性</li><li><code>Flutter</code> 預設路徑是 **’/‘**，因此如果是用預設路徑可以不需要加 <code>initialRoute: &#39;/&#39;</code>   <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  runApp(MaterialApp(</span><br><span class="line">    routes: &lt;<span class="built_in">String</span>, WidgetBuilder&gt;&#123;</span><br><span class="line">        <span class="string">&#x27;/&#x27;</span>: (context) =&gt; HomePage(),</span><br><span class="line">        <span class="string">&#x27;/second&#x27;</span>: (context) =&gt; SecondHome()</span><br><span class="line">    &#125;</span><br><span class="line">          .</span><br><span class="line">          .</span><br><span class="line">          .</span><br><span class="line">  ));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>也可以不用預設路徑自己命名</li></ul></li></ul></li></ol><h4 id="事實上，home-和-initialRiute-是一樣的，不過是一些設定上的差異而已"><a href="#事實上，home-和-initialRiute-是一樣的，不過是一些設定上的差異而已" class="headerlink" title="事實上，home 和 initialRiute 是一樣的，不過是一些設定上的差異而已"></a>事實上，<code>home</code> 和 <code>initialRiute</code> 是一樣的，不過是一些設定上的差異而已</h4><h2 id="MaterialApp會依序檢查三件事情"><a href="#MaterialApp會依序檢查三件事情" class="headerlink" title="MaterialApp會依序檢查三件事情"></a>MaterialApp會依序檢查三件事情</h2><ol><li><p>有沒有一個 Widget 被指派到 <code>home</code> 屬性</p></li><li><p>有沒有一個 map 被指派到 <code>routes</code> 屬性</p><ul><li><strong>Routes Table</strong> : 用 map 來記錄相對應的頁面<table><thead><tr><th align="center">Routes Name</th><th align="center">PageBuilder That Produces</th></tr></thead><tbody><tr><td align="center">/</td><td align="center">NewsList</td></tr><tr><td align="center">/details</td><td align="center">NewsDetail</td></tr></tbody></table><ul><li> <em>優點 : 很輕易的可以作業面的轉換</em></li><li><em>缺點 : 頁面間的資訊供通傳送會變得很複雜</em></li></ul></li></ul></li><li><p>是否有 <code>onGenerateRoute</code> callback function</p><ul><li>將 <strong>callback function</strong> 傳到 <code>MaterialApp</code></li><li>決定哪一個頁面要被顯示</li></ul></li></ol><hr><p><strong><code>routes</code> 和 <code>onGenerateRoute callback</code> 的不同</strong></p><p><img src="https://i.imgur.com/4sYklZj.png"></p><hr><h3 id="使用home屬性"><a href="#使用home屬性" class="headerlink" title="使用home屬性"></a>使用home屬性</h3><p><code>home</code> 屬性變成 <code>Navigator</code> 堆疊底部的 <code>route</code></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  runApp(<span class="keyword">new</span> MaterialApp(home: <span class="keyword">new</span> MyAppHome()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>為了加入新的 <code>route</code>(頁面) 在 stack 上面, 必須要先創建 <code>MaterialPageRoute</code> 實體. 它含有 <strong>builder function</strong> 可以 build 出畫面在 screen 上面. </p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Navigator.push(context, <span class="keyword">new</span> MaterialPageRoute&lt;<span class="keyword">void</span>&gt;(</span><br><span class="line">  builder: (BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Scaffold(</span><br><span class="line">      appBar: <span class="keyword">new</span> AppBar(title: <span class="keyword">new</span> Text(<span class="string">&#x27;My Page&#x27;</span>)),</span><br><span class="line">      body: <span class="keyword">new</span> Center(</span><br><span class="line">        child: <span class="keyword">new</span> FlatButton(</span><br><span class="line">          child: <span class="keyword">new</span> Text(<span class="string">&#x27;POP&#x27;</span>),</span><br><span class="line">          onPressed: () &#123;</span><br><span class="line">            Navigator.pop(context);</span><br><span class="line">          &#125;,</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;,</span><br><span class="line">));</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> iOS </tag>
            
            <tag> Flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 Flutter 在 iOS 和 Android  上設定 GoogleMap</title>
      <link href="2020/07/09/%E4%BD%BF%E7%94%A8-Flutter-%E5%9C%A8-iOS-%E5%92%8C-Android-%E4%B8%8A%E8%A8%AD%E5%AE%9A-GoogleMap/"/>
      <url>2020/07/09/%E4%BD%BF%E7%94%A8-Flutter-%E5%9C%A8-iOS-%E5%92%8C-Android-%E4%B8%8A%E8%A8%AD%E5%AE%9A-GoogleMap/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>如果要在 iOS 或是 Android 中使用 Google 所提供的地圖或道路資訊等等，就必須要取得 Google 配給你的 <strong><code>API key</code></strong> ，而它是用來在每次請求 Google 地圖時讓 Google 可以辨認帳戶的金鑰。所以請妥善保管你的金鑰並且由於安全的緣故不要在同一個金鑰上面開起太多功能！</p><span id="more"></span><h2 id="事前準備"><a href="#事前準備" class="headerlink" title="事前準備"></a>事前準備</h2><p>所有 Google 的服務都會經過手機內的 <strong>Google Play Services</strong> 來傳輸資料。我們可以從下圖得知應用程式是只要使用到 Google 的服務都會透過 <strong><a href="https://en.wikipedia.org/wiki/Inter-process_communication">IPC</a></strong> 與 Google Play Services 做溝通的（認證、取得資訊…）</p><p><img src="https://i.imgur.com/3yZCj4y.png"></p><p>因此記得在 <strong>Android studio</strong> 中安裝 <strong>Google Play services</strong> 不然是無法取得地圖的任何資訊喔！！！</p><p><img src="https://i.imgur.com/shqRqoM.png"></p><h2 id="Android-環境設置"><a href="#Android-環境設置" class="headerlink" title="Android 環境設置"></a>Android 環境設置</h2><p>設定 <code>google map</code> 的 <strong><code>API key</code></strong> 在 <code>AndroidManifest.xml</code> 檔案中</p><p>在該路徑底下 android/app/src/main/AndroidManifest.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">...</span></span></span><br><span class="line">  &lt;application ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">meta-data</span> <span class="attr">android:name</span>=<span class="string">&quot;com.google.android.geo.API_KEY&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">android:value</span>=<span class="string">&quot;YOUR KEY HERE&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h2 id="iOS-環境設置"><a href="#iOS-環境設置" class="headerlink" title="iOS 環境設置"></a>iOS 環境設置</h2><h3 id="Step-1"><a href="#Step-1" class="headerlink" title="Step 1"></a>Step 1</h3><p>在 cmd 建立 Flutter 專案時把預設 iOS 開發語言設定成 swift</p><blockquote><p>flutter create -i swift &lt;專案名字&gt;</p></blockquote><h3 id="Step-2"><a href="#Step-2" class="headerlink" title="Step 2"></a>Step 2</h3><p>設定 <code>google map</code> 的 <strong><code>API key</code></strong> 在 <code>Appdelegate.swift</code> 檔案中</p><p>在該路徑底下 ios/Runner/AppDelegate.swift</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="keyword">import</span> Flutter</span><br><span class="line"><span class="keyword">import</span> GoogleMaps</span><br><span class="line"></span><br><span class="line"><span class="keyword">@UIApplicationMain</span></span><br><span class="line"><span class="keyword">@objc</span> <span class="class"><span class="keyword">class</span> <span class="title">AppDelegate</span>: <span class="title">FlutterAppDelegate</span> </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">application</span>(</span></span><br><span class="line"><span class="function">    <span class="keyword">_</span> <span class="params">application</span>: <span class="type">UIApplication</span>,</span></span><br><span class="line"><span class="function">    <span class="params">didFinishLaunchingWithOptions</span> <span class="params">launchOptions</span>: [<span class="params">UIApplicationLaunchOptionsKey</span>: <span class="keyword">Any</span>]<span class="operator">?</span></span></span><br><span class="line"><span class="function">  )</span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="type">GMSServices</span>.provideAPIKey(<span class="string">&quot;YOUR KEY HERE&quot;</span>)</span><br><span class="line">    <span class="type">GeneratedPluginRegistrant</span>.register(with: <span class="keyword">self</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.application(application, didFinishLaunchingWithOptions: launchOptions)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Step-3"><a href="#Step-3" class="headerlink" title="Step 3"></a>Step 3</h3><p>確保 iOS 裝置可以支援地圖渲染還需要加入以下設定在該檔案中</p><p>在該路徑底下ios/Runner/Info.plist</p><figure class="highlight plist"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>io.flutter.embedded_views_preview<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">true</span>/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="完成！！！"><a href="#完成！！！" class="headerlink" title="完成！！！"></a>完成！！！</h3>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> iOS </tag>
            
            <tag> Flutter </tag>
            
            <tag> Google Map </tag>
            
            <tag> Google Play services </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter 筆記(二) - 狀態管理</title>
      <link href="2020/06/16/Flutter%20%E7%AD%86%E8%A8%98(%E4%BA%8C)%20-%20%E7%8B%80%E6%85%8B%E7%AE%A1%E7%90%86/"/>
      <url>2020/06/16/Flutter%20%E7%AD%86%E8%A8%98(%E4%BA%8C)%20-%20%E7%8B%80%E6%85%8B%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本篇記錄了 Flutter 眾多概念中較為複雜的一個領域，那就是 <strong>狀態管理 State Management</strong> 的部分。然而之所以複雜的原因就是它並沒有一套實作的標準。例如 Google 自行發表的 <strong>BLoC Pattern</strong> 、 <strong>Rx</strong> 系列以及 Flutter 原生的狀態管理，都會在這篇一一做出差異比較與使用時機。</p><span id="more"></span><h1 id="Flutter-完整開發架構"><a href="#Flutter-完整開發架構" class="headerlink" title="Flutter 完整開發架構"></a>Flutter 完整開發架構</h1><h2 id="Stream-初識"><a href="#Stream-初識" class="headerlink" title="Stream 初識"></a>Stream 初識</h2><ul><li><p><strong>比喻</strong><br>  <img src="https://i.imgur.com/B9IuUh1.png"></p></li><li><p>巧克力工廠的特色</p><ol><li>工廠收到一個 ‘order’, 做一些處理後, 將蛋糕從工廠的另外一端吐出</li><li>當有第一個訂單以前工廠是尚未建立的</li><li>工廠花大多數的時間在等訂單進來</li><li>必須有人（order taker ：) 等待新的訂單. 這是進入工廠的入口</li><li>當蛋糕做好的時候必須有人來拿</li></ol></li></ul><p>來一段程式碼 ：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;dart:async&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代表比喻中工廠另一端所生產出來的蛋糕</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cake</span></span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 代表比喻中裡面的訂單（消費者拿給order taker）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span></span>&#123; </span><br><span class="line">  <span class="built_in">String</span> type; <span class="comment">// 什麼樣類型的蛋糕</span></span><br><span class="line">  Order(<span class="keyword">this</span>.type);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="comment">//1.自動生成sink和stream物件並指派給參考</span></span><br><span class="line">  <span class="keyword">var</span> controller = StreamController();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//2.消費者有一個香蕉蛋糕的訂單</span></span><br><span class="line">  <span class="keyword">final</span> order = Order(<span class="string">&#x27;banana&#x27;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//5.</span></span><br><span class="line">  <span class="keyword">final</span> baker = StreamTransformer.fromHandlers(</span><br><span class="line">    <span class="comment">//第一個參數為用來傳入order inspector所抽取的data event</span></span><br><span class="line">    <span class="comment">//第二個參數為sink, 用來將data event放回stream</span></span><br><span class="line">    handleData: (cakeType, sink) &#123;</span><br><span class="line">      <span class="comment">//如果抽取的資料和baker可以製作的元素型態是一致的就將</span></span><br><span class="line">      <span class="comment">//蛋糕(data event)放回sink當中變回stream</span></span><br><span class="line">      <span class="keyword">if</span> (cakeType == <span class="string">&#x27;chocolate&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">//這裡的sink和stream.sink的sink是不同的, 我們不會</span></span><br><span class="line">        <span class="comment">//從頭開始處理stream</span></span><br><span class="line">        sink.add(Cake());</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sink.addError(<span class="string">&#x27;I cant bake that type!!!&#x27;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  );</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//3.將訂單加入到sink裡面去 (order taker)</span></span><br><span class="line">  controller.sink.add(order);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//stream 代表工廠</span></span><br><span class="line">  <span class="comment">//map 將所有加入到stream裡面的元素(order)一一取出來</span></span><br><span class="line">  <span class="comment">//匿名函式 代表order inspector</span></span><br><span class="line">  <span class="comment">//他不關心進來的元素(訂單)是啥, 他抽取出她想要的</span></span><br><span class="line">  <span class="comment">//屬性(可以單一或是多個)或是改變(transform)進來的元素</span></span><br><span class="line">  <span class="comment">//這裡是抽取訂單裡的type屬性(String)並將它傳給baker</span></span><br><span class="line">  controller.stream</span><br><span class="line">    <span class="comment">//4. </span></span><br><span class="line">    .map((order) =&gt; order.type)</span><br><span class="line">    <span class="comment">//6. 將event塞回stream</span></span><br><span class="line">    .transform(baker)</span><br><span class="line">    <span class="comment">//7. 代表pickup offfice, 將stream裡面的元素取出</span></span><br><span class="line">    .listen( <span class="comment">//和stream是做綁定的</span></span><br><span class="line">    <span class="comment">// 正確的data event這裡就是蛋糕</span></span><br><span class="line">        (cake) =&gt; <span class="built_in">print</span>(<span class="string">&#x27;Heres your cake <span class="subst">$cake</span>&#x27;</span>),</span><br><span class="line">    <span class="comment">// 不正確的資料 error event</span></span><br><span class="line">    onError: (err) =&gt; <span class="built_in">print</span>(err)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>I cant bake your type!!!</p></blockquote><img src="https://i.imgur.com/PAwcvsJ.png" width="700" height="400" /><h4 id="什麼是-StreamController"><a href="#什麼是-StreamController" class="headerlink" title="什麼是 StreamController"></a>什麼是 StreamController</h4><ol><li><p><code>StreamController</code> 有其中兩個屬性 <code>sink</code> 和 <code>stream</code></p></li><li><p>當 <code>StreamController</code> 被創建時, 會自動生成該兩個物件並指派</p></li><li><p><code>sink</code> 有能力將data傳入<code>stream</code>裡面</p></li><li><p>不能直接將資料傳給<code>stream</code>, 需要透過<code>sink</code>(order taker)</p></li></ol><h4 id="總覽"><a href="#總覽" class="headerlink" title="總覽"></a>總覽</h4><p><img src="https://i.imgur.com/JX8YUp6.png"></p><ul><li><strong>Order Taker</strong> : <code>StreamController</code> 的 <code>sink.add</code> 函數 <ul><li>功能 : 將加入的 event 提供給 stream 去處理</li></ul></li><li><strong>Order Inspector</strong> : <code>stream</code> 的map函數<ul><li>功能 : 檢視每一個進來 <code>stream</code> 的 event , 並加以處理(抽取或轉換)然後返回</li></ul></li></ul><ul><li><p><strong>Baker</strong> : <code>StreamTransformer</code></p><ul><li>功能 : 處理每一個進來的處理過的資料, 然後塞回<code>stream</code></li></ul></li><li><p><strong>Pickup Office</strong> : <code>listen</code>函式</p></li></ul><hr><p><strong>map function 和 StreamTransformer 的差別</strong><br>相同 : </p><ul><li>都是用來處理 stream 裡面的 event</li></ul><p>不同 : </p><ul><li><code>map function</code> : 一對一的data進出</li><li><code>StreamTransformer</code> : 一對多的資料進出(輸出多個資料)<ul><li>更加彈性</li><li>e.g. 可以呼叫多次 <code>sink.add</code> , 將 event data 加入到 stream</li></ul></li></ul><hr><h2 id="Why-Stream"><a href="#Why-Stream" class="headerlink" title="Why Stream ?"></a>Why Stream ?</h2><img src="https://i.imgur.com/FYyQ0LW.png" width="500" height="300" /><hr><h4 id="緣起"><a href="#緣起" class="headerlink" title="緣起"></a>緣起</h4><p><code>Stream</code> 的處理方式看似複雜, 但在 flutter 或 dart 裡面經常會提供觸發的事件資料(透過 sink 放入 stream 裡面), 而無需自己製作. 我們只需創建另一個 <code>stream</code> 用</p><hr><p>來看一段程式碼 ：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;dart:html&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">final</span> ButtonElement button = <span class="built_in">querySelector</span>(<span class="string">&#x27;button&#x27;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// onClick方法會返回一個stream(在此之前, flutter/dart會幫我們</span></span><br><span class="line">  <span class="comment">//處理透過sink將事件塞入stream的過程)在每一次我們按按鈕時會射出一個事件</span></span><br><span class="line">  button.onClick</span><br><span class="line">    .timeout( <span class="comment">// 會創建一個新的stream(手動)</span></span><br><span class="line">  <span class="built_in">Duration</span>(seconds: <span class="number">1</span>), <span class="comment">// 超過一秒中沒有新的事件</span></span><br><span class="line">    <span class="comment">// 將事件加入到sink當中(sink 之後會交給新的stream)</span></span><br><span class="line">    onTimeout: (sink) =&gt; sink.addError(<span class="string">&#x27;You lost!!!&#x27;</span>)</span><br><span class="line">    )</span><br><span class="line">    <span class="comment">// .map(event) =&gt; &#x27;sucess&#x27;) 可以加入這行做額外的轉換</span></span><br><span class="line">    .listen(</span><br><span class="line">        (event) &#123;&#125;,</span><br><span class="line">    onError: (err) =&gt; <span class="built_in">print</span>(err)</span><br><span class="line">    );</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- ![](https://i.imgur.com/kzM0rfr.png) --><img src="https://i.imgur.com/kzM0rfr.png" width="600" height="400" /><h2 id="Stream-‘take’-and-‘where’-function"><a href="#Stream-‘take’-and-‘where’-function" class="headerlink" title="Stream ‘take’ and ‘where’ function ?"></a>Stream ‘take’ and ‘where’ function ?</h2><ul><li><strong>take(int)</strong> - 當事件進入到 <code>stream</code> 的次數高達設定的數字時, <code>stream</code> 會被終止且發出結束事件(onDone)</li><li><strong>where((){})</strong><ul><li>事實上他就是<strong>過濾器</strong>, 專門過濾不符合匿名韓式裡寫的條件. <ul><li>true : 保留該 event</li><li>false : 忽略該 event</li></ul></li><li>創建新的 <code>stream</code> 並將 event 塞入</li></ul></li></ul><img src="https://i.imgur.com/4797yCz.png" width="600" height="150" /><p>猜字遊戲 : 當猜到第四次仍沒有猜中就不可以再猜了ＸＸＤ</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;dart:html&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">final</span> ButtonElement button = <span class="built_in">querySelector</span>(<span class="string">&#x27;button&#x27;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">final</span> InputElement input = <span class="built_in">querySelector</span>(<span class="string">&#x27;input&#x27;</span>);</span><br><span class="line">  </span><br><span class="line">  button.onClick</span><br><span class="line">    .take(<span class="number">4</span>) <span class="comment">//限制stream可以流進event的次數</span></span><br><span class="line">    <span class="comment">// event在這裡就只是表達按下按鈕的事件</span></span><br><span class="line">    <span class="comment">// 如果正確就將event傳下去, 反之就忽略該事件</span></span><br><span class="line">    .where((event) &#123;</span><br><span class="line">      <span class="keyword">var</span> test = input.value == <span class="string">&#x27;banana&#x27;</span>;</span><br><span class="line">      input.value = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">      <span class="keyword">return</span> test;</span><br><span class="line">    &#125;) <span class="comment">//創建一個stream</span></span><br><span class="line">    .listen(</span><br><span class="line">    (event) =&gt; <span class="built_in">print</span>(<span class="string">&#x27;You win!!!&#x27;</span>),</span><br><span class="line">    <span class="comment">// 當原始的stream已經傳入四次的event, 就終止該stream並傳遞結束事件</span></span><br><span class="line">    onDone: () =&gt; <span class="built_in">print</span>(<span class="string">&#x27;Nope, bad guess&#x27;</span>)</span><br><span class="line">    );</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外一個例子更可以展現 ：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;dart:html&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;dart:async&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">final</span> InputElement input = <span class="built_in">querySelector</span>(<span class="string">&#x27;input&#x27;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">final</span> DivElement div = <span class="built_in">querySelector</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">  </span><br><span class="line"><span class="comment">//   div.innerHtml = &#x27;Enter a valid email&#x27;;</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">final</span> validator = StreamTransformer.fromHandlers(</span><br><span class="line">  handleData: (email, sink) &#123;</span><br><span class="line">      <span class="keyword">if</span> (email.contains(<span class="string">&#x27;@&#x27;</span>)) &#123;</span><br><span class="line">        sink.add(email);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sink.addError(<span class="string">&#x27;Enter a valid email&#x27;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">   </span><br><span class="line">  input.onInput</span><br><span class="line">    <span class="comment">//不管input event這個物件, 只抽取其中需要的資訊(email資料)</span></span><br><span class="line">    .map((<span class="built_in">dynamic</span> event) =&gt; event.target.value)</span><br><span class="line">    <span class="comment">//判斷event是否為正確的email, 將對或錯的結果分別寫入sink中</span></span><br><span class="line">    .transform(validator)</span><br><span class="line">    .listen(</span><br><span class="line">  (event) =&gt; div.innerHtml = <span class="string">&#x27;&#x27;</span> ,</span><br><span class="line">    onError: (err) =&gt; div.innerHtml = err</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://i.imgur.com/WpeEWlc.png" width="700" height="400" /><h2 id="BLOC’s-vs-Stateful-widgets"><a href="#BLOC’s-vs-Stateful-widgets" class="headerlink" title="BLOC’s vs Stateful widgets"></a>BLOC’s vs Stateful widgets</h2><hr><p><strong>前情提要</strong></p><p><img src="https://i.imgur.com/u6YOVgL.png"></p><hr><h4 id="場景-：-BLOC-對於資訊共享於不同-widget-之間做出很好的處理"><a href="#場景-：-BLOC-對於資訊共享於不同-widget-之間做出很好的處理" class="headerlink" title="場景 ： BLOC 對於資訊共享於不同 widget 之間做出很好的處理"></a>場景 ： BLOC 對於資訊共享於不同 widget 之間做出很好的處理</h4><img src="https://i.imgur.com/wXiUEgw.png" width="700" height="400" /><ul><li>整個 app 的 widget 結構<img src="https://i.imgur.com/QZ5VaZh.png" width="350" height="500" /></li><li>當 LoginScreen 和 UserPreferences 都要共享下圖紅色圈起來的資料, 如果單純使用 stateful widgets 來寫會很複雜. 但是 bloc 可以輕易的解決 widget 和 widget 之間共享資料的難度</li></ul><hr><p><strong>BLOC : Business logic component</strong> </p><ol><li><p>用來儲存所有資料(data)和狀態(state)在一個實體當中</p></li><li><p><code>bloc component</code> 並不需要app裡頭哪一個特定的widget做綁定</p></li><li><p>與 <code>widget</code> 是分離的, 並不會在 <code>widget tree</code> 的結構當中</p></li></ol><!-- ![](https://i.imgur.com/XCpAL6M.png) --><img src="https://i.imgur.com/XCpAL6M.png" width="700" height="400" /><hr><h2 id="streams-在-bloc-裡頭的意義"><a href="#streams-在-bloc-裡頭的意義" class="headerlink" title="streams 在 bloc 裡頭的意義"></a>streams 在 bloc 裡頭的意義</h2><p>下圖是bloc和stream一起運作的概念 :<br><img src="https://i.imgur.com/31j8ZDR.png" width="700" height="300" /></p><ul><li><code>bloc</code> 可以看作是<strong>物流中心</strong>, 用來管理 app 所有數據和狀態的</li><li><code>stream</code> 可以看作是各式各樣需要<strong>物流的產品</strong>, 在哪裡得到資訊？ 將資訊送往哪裡？</li></ul><p>下圖是app的結構 :<br><img src="https://i.imgur.com/9P2sqZK.png" width="500" height="500" /></p><h2 id="Bloc-的應用"><a href="#Bloc-的應用" class="headerlink" title="Bloc 的應用"></a>Bloc 的應用</h2><p><code>TextField</code> 和 <code>bloc</code> 互相作用 :<br>    <img src="https://i.imgur.com/VdpNStC.png" width="700" height="400" /><br><code>bloc</code> 擁有兩個屬性 :</p><ol><li>Email StreamController</li><li>Password StreamController</li></ol><p>對於如何應用 <code>bloc</code> 到 app 裏頭, 在 <code>state management</code> 尚未有一個統一的說法 : </p><img src="https://i.imgur.com/YCksDI8.png" width="700" height="200" /><h4 id="1-Single-Global-Instance-適合用於在較小的項目當中"><a href="#1-Single-Global-Instance-適合用於在較小的項目當中" class="headerlink" title="1. Single Global Instance : 適合用於在較小的項目當中"></a>1. <strong>Single Global Instance</strong> : 適合用於在較小的項目當中</h4><img src="https://i.imgur.com/viyq6La.png" width="700" height="400" /><ul><li><p>(中間) <code>app</code> 的 <code>widget</code> 結構</p></li><li><p>(右邊) <code>bloc.dart</code> 檔按裡面有一個 <code>Bloc</code> 類以及一個 <code>bloc</code> 實體</p></li><li><p><strong>在整個 app 中只有一份 (<code>final</code>)<code>bloc</code> 實體, 所以裡面所有的變數和狀態是共享的在所有使用到的  <code>widget</code> 當中</strong></p></li><li><p>開發上會非常方便且簡易但是會難以控制</p></li></ul><h4 id="2-Scoped-Instance-適合在更大型且更複雜的項目底下開發"><a href="#2-Scoped-Instance-適合在更大型且更複雜的項目底下開發" class="headerlink" title="2. Scoped Instance : 適合在更大型且更複雜的項目底下開發"></a>2. <strong>Scoped Instance</strong> : 適合在更大型且更複雜的項目底下開發</h4><img src="https://i.imgur.com/yqHS6zH.png" width="700" height="400" /><ul><li>不把 <code>bloc</code> 的實體放在 <code>bloc.dart</code> 檔案下來當作全域變數</li><li>下面的 CustomWidget1~3 是任意的</li><li><strong>將 bloc 放在需要的 widget 裡面, 而其子widget都可以存取到該 <code>bloc</code></strong></li><li>不需將 bloc 實體暴露給整個 app 做使用</li><li>這樣開發明顯會複雜許多但會得到更好的控制</li></ul><h2 id="StreamBuilder-consuming-stream"><a href="#StreamBuilder-consuming-stream" class="headerlink" title="StreamBuilder - consuming stream"></a>StreamBuilder - consuming stream</h2><ul><li><p>定義 : 是一個可以將使用者定義的物件的串流轉成widget的widget</p></li><li><p>兩個參數 : </p><ol><li>stream : 要監測事件的 stream</li><li>builder : <strong>將串流裡的元素轉換成 widget</strong> (builder function)<ul><li><strong>觸發條件為當 stream 改變</strong> </li></ul></li></ol>  <img src="https://i.imgur.com/Y9myG10.png" width="700" height="400" /></li></ul><hr><p><strong>StreamBuilder 概述</strong></p><ol><li>Flutter 所提供的一個 widget</li><li>將需要的 <code>Stream</code> 和 <code>StreamBuilder</code> 做綁定</li><li><strong>當 <code>StreamBuiler</code> 偵測到一個新的事件從 <code>stream</code> 進來, 就調用 <code>builder function</code> (返回新的widget )並且重新渲染</strong></li></ol><h4 id="通常應用來更新-渲染-widget-取代原有使用-statefulWidget-的-setState"><a href="#通常應用來更新-渲染-widget-取代原有使用-statefulWidget-的-setState" class="headerlink" title="通常應用來更新(渲染) widget 取代原有使用 statefulWidget 的 setState()"></a>通常應用來更新(渲染) widget 取代原有使用 statefulWidget 的 setState()</h4><hr><h2 id="context"><a href="#context" class="headerlink" title="context"></a>context</h2><img src="https://i.imgur.com/C5wQrPm.png" width="700" height="400" /><p><strong>概念</strong></p><ol><li><p>每一個widget都有自己獨立的 <code>context</code></p></li><li><p><code>context</code> 是一種標示符, 將該 widget 放置在正確的 widget 階層中(如上圖)</p></li><li><p>每一個 widget 都可以在 widget 階層中向上尋找任意的 widget</p></li><li><p>每一個 widget 都知道自己的 <code>context</code> 以及以上的 <code>context</code></p></li><li><p><code>context</code> 就像鏈結一樣, 該 <code>context</code> 知道他的上級而上級的 <code>context</code> 又知道他的上級…</p></li></ol><p><strong>來看一段程式碼 :</strong> </p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter/material.dart&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;bloc.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Provider</span> <span class="keyword">extends</span> <span class="title">InheritedWidget</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> bloc = Bloc();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">bool</span> updateShouldNotify(_) =&gt; <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//該方法簡單來說就是讓該widget底下的任意widget都可以連結到Provider</span></span><br><span class="line">  <span class="comment">//, 來對Bloc做存取</span></span><br><span class="line">  <span class="keyword">static</span> Bloc of(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> (context.inheritFromWidgetOfExactType(Provider) <span class="keyword">as</span> Provider).bloc;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>程式碼概述 :</strong></p><ol><li><p>在該 widget(<code>Provider</code>) 底下 widget tree 的任意 widget , 都可以藉由該 <code>of(BuilderContext)</code>  將自己的 <code>context</code> 傳入</p></li><li><p>該 <code>context</code> 有一個 <code>inheritFromWidgetOfExactType(Type typeTarget)</code> 方法, 用來向上尋找     widget 階層中類型為 <code>typeTarget</code> 的 widget.</p></li><li><p>找到後會返回一個 <code>InheritedWidget</code> 類型的 widget(物件) 並將他向下轉型為 <code>typeTarget</code></p></li></ol><h2 id="How-to-merge-two-stream"><a href="#How-to-merge-two-stream" class="headerlink" title="How to merge two stream ?"></a>How to merge two stream ?</h2><p><strong>Case : 監聽兩個 <code>stream</code> 當達到一定的條件作出適當的響應</strong></p><img src="https://i.imgur.com/7P6HCqf.png" width="700" height="400" /><h3 id="solution-to-merge-stream"><a href="#solution-to-merge-stream" class="headerlink" title="solution to merge stream"></a>solution to merge stream</h3><p><strong>有三種解決的辦法 :</strong></p><img src="https://i.imgur.com/jnmv79E.png" width="700" height="400" /><p>下面有對RxDart有做詳細的解說</p><h2 id="RxDart"><a href="#RxDart" class="headerlink" title="RxDart"></a>RxDart</h2><h3 id="Rx家族介紹"><a href="#Rx家族介紹" class="headerlink" title="Rx家族介紹"></a>Rx家族介紹</h3><img src="https://i.imgur.com/sNw65QO.png" width="700" height="400" /><ol><li><p><strong>Rx</strong> 全名叫做 <a href="http://reactivex.io/"><strong>ReactiveX</strong></a></p></li><li><p>有多種不同的版本套件</p></li><li><p>依據不同的程式語言去量身定做</p></li><li><p>架構在不同版本間基本上都是一樣</p></li><li><p>不同的術語在 RxDart</p><ul><li><code>Stream</code> 會變成 <code>Observable</code> <ul><li>A wrapper class that extends to Stream</li></ul></li><li><code>StreamController</code>會變成<code>Subject</code><ul><li>A wrapper class that extends to StreamController</li></ul></li></ul><p> <br><img src="https://i.imgur.com/ZyF6DjD.png" width="700" height="400" /></p></li></ol><hr><p><strong>知識補給站</strong><br><code>BehaviorSubject</code> 是 <code>StreamController</code> 的一種. </p><ol><li><p>默認是 Broadcast controller , 所以他的 <code>stream</code> 是可以被監聽多次的</p></li><li><p>會紀錄最新加入 <code>sink</code> 的 event , 以便之後可以做存去使用. </p></li><li><p><strong>在 <code>Stream</code> 的處理方面加入許多延伸的功能</strong></p></li></ol><p><strong>學習連結</strong></p><p><a href="https://pub.dartlang.org/documentation/rxdart/latest/"><strong>完全RxDart教學手冊</strong></a></p><hr><p><strong>回到正題 =&gt; 我們將用RxDart的 <code>combineLatest2()</code> 方法讓兩個 <code>stream</code> 做出合併處理</strong></p><!-- ![](https://i.imgur.com/hAHWXuQ.png) --><img src="https://i.imgur.com/hAHWXuQ.png" width="400" height="500" /><h4 id="combineLatest2-的機制圖解"><a href="#combineLatest2-的機制圖解" class="headerlink" title="combineLatest2() 的機制圖解"></a><code>combineLatest2()</code> 的機制圖解</h4><ul><li><img src="https://i.imgur.com/h0kIBe9.png"><a href="http://rxmarbles.com/#combineLatest">觀念圖示連結</a><ul><li><strong><code>Observale</code> 直到要合併的兩個 <code>stream</code> 都各至少發出一個 event 才會發出 event</strong></li></ul></li></ul><h2 id="Bloc-總結"><a href="#Bloc-總結" class="headerlink" title="Bloc 總結"></a>Bloc 總結</h2><img src="https://i.imgur.com/3lJAeVY.png" width="700" height="400" />]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> iOS </tag>
            
            <tag> Flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter 筆記(ㄧ) - 基礎認識</title>
      <link href="2020/04/09/Flutter-%E7%AD%86%E8%A8%98-%E3%84%A7-%E5%9F%BA%E7%A4%8E%E8%AA%8D%E8%AD%98/"/>
      <url>2020/04/09/Flutter-%E7%AD%86%E8%A8%98-%E3%84%A7-%E5%9F%BA%E7%A4%8E%E8%AA%8D%E8%AD%98/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本篇記錄了 Flutter UI Framework 最基本的結構來認識它的渲染機制還有一些基本 Widget 的理解，以及  Flutter 所採用的 <strong>UI as Code</strong> 的開發方式是如何進行的。系列文章主要是 <a href="https://www.udemy.com/course/dart-and-flutter-the-complete-developers-guide/">Stephen Grider</a> 教學的筆記心得。</p><span id="more"></span><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><ul><li>在Flutter裡面, 幾乎所有東西都是小部件, 包括 alignment, padding </li><li><strong>Stateless widgets</strong> 是不可變的, 也就是說所有的屬性都不能改變 - <strong>所有的數值都是final</strong></li></ul><ul><li><p><strong>Stateful widgets</strong> 維護在 widget 的生命週期中可能會改變的狀態(使用者交互, 更新資料等等)</p><ul><li><p>實作一個 <code>Stateful widget</code> 需要至少兩個 class : </p><ol><li>SatefulWidget class 創造一個</li><li>State class 的實體</li></ol></li><li><p>SatefulWidget class <strong>本身是不可變的(和 Stateles s一樣)</strong>, 但是 State class 可以在小部件的生命週期中持續存在</p></li><li><p><strong>widget 的 state 會被緩衝(不被重新創建), 當 widget 被重新渲染會創建新的 widget 但他仍然使用被緩衝 state 的資料</strong></p></li></ul></li></ul><h2 id="Stateflul-Widget-v-s-Stateless-Widget"><a href="#Stateflul-Widget-v-s-Stateless-Widget" class="headerlink" title="Stateflul Widget v.s. Stateless Widget"></a>Stateflul Widget v.s. Stateless Widget</h2><img src="https://i.imgur.com/GXZ29ps.png" width="700" height="400" /><ul><li><p><code>Stateless Widget</code> 雖說裡面的屬性和狀態不能被改變, <strong>但資料可以在外面被改變傳進來, 來重新渲染該widget</strong></p></li><li><p><code>Stateful Widget</code> 就更好理解</p><ol><li>可以透過外面傳進來的資料去改變</li><li>可以透過本地的 state 來改變</li></ol></li></ul><h2 id="debugging-UI"><a href="#debugging-UI" class="headerlink" title="debugging UI"></a>debugging UI</h2><p>檢查整個app UI的介面 :</p><ol><li><p>添加依賴</p><ul><li><blockquote><p>import ‘package:flutter/rendering.dart’; </p></blockquote></li></ul></li><li><p>在<code>main</code>裡面呼叫UI debugger</p><ul><li><blockquote><p>debugPaintSizeEnabled = true;</p></blockquote></li></ul></li></ol><hr><p><strong>其他debugger</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查看text的基準線（少用）</span></span><br><span class="line">debugPaintBaselinesEnabled = <span class="keyword">true</span>;</span><br><span class="line"><span class="comment">// 查看在螢幕上的觸控</span></span><br><span class="line">debugPaintPointersEnabled = <span class="keyword">true</span>; </span><br></pre></td></tr></table></figure><hr><h2 id="ListView"><a href="#ListView" class="headerlink" title="ListView"></a>ListView</h2><p><strong>定義</strong> : 最常被用來滑動的 widget. <strong>他展示了她一個接一個的子 widget 在滑動的方向上</strong> <code>(如果是橫向展示子 widget 被要求填滿 ListView)</code></p><p>以下有三種不同的選項來建構ListView :<br><a href="https://docs.flutter.io/flutter/widgets/ListView-class.html">ListView doc</a></p><img src="https://i.imgur.com/VJccWQh.png" width="700" height="400" /><h2 id="Flutter-系統簡介"><a href="#Flutter-系統簡介" class="headerlink" title="Flutter 系統簡介"></a>Flutter 系統簡介</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul><li><p>Flutter 系統簡介</p><ul><li><em><strong>Flutter 框架的本身是由許多層的抽象組成堆疊的</strong></em></li></ul>  <img src="https://i.imgur.com/4Xgkl0g.png" width="700" height="400" />  </li><li><p>可以大概簡化成</p><ul><li><img src="https://i.imgur.com/ej0nkJf.png"></li><li><strong>Material Cupertino &amp; widget</strong> 是最上層也最常接觸到的一層<ul><li>e.g. 像是 <code>Scaffold</code> &amp; <code>FloatingActionButton</code> … 是屬於 <code>Material</code> 庫 ; <code>Column</code> &amp; <code>GestureDetector</code> … 是屬於 <code>Widgets</code> 庫</li></ul></li><li><strong>rendering layer</strong> 主要負責簡化外觀渲染的工作</li><li><strong>dart:ui</strong> 就是基本負責與更底層的 <code>Flutter engine</code> 溝通</li></ul></li></ul><hr><p><strong>小結</strong><br>越上層越容易控制使用，但越下層可以有更多複雜度的精細掌握</p><hr><h3 id="dart-ui"><a href="#dart-ui" class="headerlink" title="dart:ui"></a>dart:ui</h3><hr><p><strong>功能</strong><br>該 <code>lib</code> 提供最底層的<strong>服務</strong>給 <code>Flutter</code> 框架用來引導整個應用程式，像是提供<strong>類別</strong>來驅動<strong>輸入 圖像文字 外觀 還有渲染系統</strong></p><hr><p>根據上述，有了 <strong>dart:ui</strong> 就可以開始開發了，因為它提供最基本的 (<code>Canvas</code>, <code>Paint</code> <code>TextBox</code>) 等物件</p><ul><li><strong>缺點是難以管理</strong><ol><li>需要設計繪畫的所有座標</li><li>管理好每一張 <strong>frame</strong></li></ol></li><li>除了，小型專案適用 </li></ul><h3 id="Rendering-Library"><a href="#Rendering-Library" class="headerlink" title="Rendering Library"></a>Rendering Library</h3><hr><p><em><strong>The Flutter rendering tree</strong></em></p><ul><li><p><strong>定義</strong></p><ul><li>一個在 <code>render tree</code> 裡的物件</li></ul></li><li><p><strong>功能</strong></p><ul><li><code>RenderObject</code> <strong>hierarchy</strong> 是被 <code>Flutter</code> 的 <code>Widgets lib</code> 來使用的，用來實現其佈局還有後端的渲染</li></ul></li></ul><hr><ul><li><p>根據上述，<em>該層完成所有 Flutter 框架中負擔最重的部分（包含所有計算繪畫追蹤 frame 等部分）</em></p></li><li><p><strong><code>RenderObject</code></strong> 想像成車子的引擎，他們負責實際渲染到 app 畫面的工作</p></li><li><p>The tree is composed out of RenderObjects</p></li><li><p>實例化一個 <code>RenderObject</code> 是非常昂貴且耗時的，所以會盡量的 <code>cache</code> 以避免資源的消耗 （所以 flutter 為何如此高效） </p></li></ul><h3 id="Widgets"><a href="#Widgets" class="headerlink" title="Widgets"></a>Widgets</h3><hr><p><strong>Widgets 和 RenderObject 的關係</strong></p><p>這大概是我們最可以輕易使用的 <code>UI component</code>，每一個可以在 <code>widget lib</code> 裡面找到的 <code>widget</code> 都會有一個相對應的 <code>RenderObject</code> 在 <code>rendering lib</code> 裏來負責最終的渲染</p><hr><p>所有的 <code>Widgets</code> 可以分成這三類</p><ol><li><p><strong>Layout</strong> e.g. <code>column</code> <code>row</code></p></li><li><p><strong>Painting</strong> e.g. <code>Text</code> <code>image</code></p></li><li><p><strong>Hit-Testing</strong> e.g. <code>GestureDetector</code> 用來辨識所有的觸控</p></li></ol><p>所有複雜的 <code>widget</code> 都是由以上這三種類別 <strong><code>wrap</code></strong> 而成</p><ul><li><p>e.g. 製作一個 <code>Button</code> 可以由 <code>GestureDetector</code> 再 <strong>包裝 wrap</strong> 一個 <code>Container</code> 而成</p></li><li><p><em><strong>這種方式在 OO 叫做 composition 而不是 inheritance</strong></em></p></li></ul><h3 id="Material-amp-Cupertino-library"><a href="#Material-amp-Cupertino-library" class="headerlink" title="Material &amp; Cupertino library"></a>Material &amp; Cupertino library</h3><hr><p><strong>Widgets lib all the time ?</strong><br>其實除了自己組合所有複雜的 <code>widget</code> 也可以使用已經實作好的 Android &amp; iOS 常用的設計元件</p><hr><h2 id="建構-Flutter-UI-的詳細流程-Widget-Element-RenderObject"><a href="#建構-Flutter-UI-的詳細流程-Widget-Element-RenderObject" class="headerlink" title="建構 Flutter UI 的詳細流程 (Widget, Element, RenderObject)"></a>建構 Flutter UI 的詳細流程 (Widget, Element, RenderObject)</h2><p>以此程式為例</p><ul><li><p><img src="https://i.imgur.com/5Hbl5PU.png"></p></li><li><p>由外往裡包的 widget 分別是 <code>SimpleApp</code> =&gt; <code>SimpleContainer</code> =&gt; <code>SimpleText</code></p></li></ul><p>整個 building (呼叫 <code>runApp()</code>) 的過程大概可以分成三個步驟，每一個步驟都有自己的 <code>tree</code></p><ol><li>Flutter 會建立一個包含這三個 widget 的 <strong><code>widget tree</code></strong></li><li>Flutter 會迭代整個 <code>widget tree</code> 並且創建第二個樹 - <code>element tree</code>。在迭代的過程中，每一個 <code>widget</code> 都會呼叫 <code>createElement()</code> 來實例化相對應得 <code>Element</code> 物件，並且將它塞到 <code>element tree</code> 裡面</li><li>以此類推，第三棵樹 - <code>RenderTree</code>，透過 <code>Element</code> 呼叫 <code>createRenderObject()</code> 產生 <code>RenderObject</code> 並且塞到 <code>RenderTree</code></li></ol><p>圖示<br>    <img src="https://i.imgur.com/eiZ09A5.png"></p><h3 id="Widget-Element-RenderObject"><a href="#Widget-Element-RenderObject" class="headerlink" title="Widget? Element? RenderObject?"></a>Widget? Element? RenderObject?</h3><p><strong>每一個 <code>Element</code> 都會有一個 <em>reference</em> 參考到與其對應的 <code>Widget</code> 和 <code>RenderObject</code></strong></p><hr><p><strong>為什麼需要使用 Element 的前情提要：</strong></p><p><code>RenderObject</code> 包含了渲染與之相對應 <code>Widget</code> 的所有邏輯，因此實例化是相當昂貴的！所以盡可能地將它保留在記憶體中不要回收持續地利用</p><hr><p><strong>Elements</strong><br>特性</p><ul><li>就像一個<strong>代理人</strong>一樣連接兩端(reference)，在不可變的 Widget tree 和可變的 RenderObject tree 之間 (immutable &amp; mutable)</li></ul><p>功能</p><ul><li>用來比較同個位置下的 <code>Widget</code> 和 <code>RenderObject</code></li></ul><h4 id="為什麼要三棵樹不是一棵樹？"><a href="#為什麼要三棵樹不是一棵樹？" class="headerlink" title="為什麼要三棵樹不是一棵樹？"></a>為什麼要三棵樹不是一棵樹？</h4><p><strong>效能！！！</strong></p><p>當每一次 <code>widget tree</code> 有改變的時候 (可能是某層換不同型態的 widget 或只是 widget 設定的更新)， Flutter 用 <code>element tree</code> 來比較新建立的 <code>Widget tree</code> 和已經存在建立的 <code>RenderObject tree</code> </p><ol><li>當該層的Widget和之前的 <strong>類別 type</strong> 是一樣的，就不需要重新建立相對應昂貴的 <code>RenderObject</code>，而是只需要更新 <code>widget</code> 有變動的設定給現有的 <code>RenderObject</code> 就行了</li><li>反之，該層的 <code>Widget</code> 和之前的類別是不一樣的，就把舊的 <code>widget</code>, <code>element</code>, <code>renderObject</code> 刪掉 （<strong>包括其子樹</strong>），然後重新創建相對應的 <code>elemnt</code> 和 <code>renderObject</code></li></ol><p>以此類推，迭代這三棵樹裡的所有物件</p><p><strong>Widget 是輕量的所以可以被輕易的建造和消除所以適合用來描述目前的狀態和設定，反之 RenderObject 是重量級的所以應審慎的創建和回收</strong></p><p><strong>The whole app acts like a huge RecyclerView</strong></p><hr><p><strong>BuildContext 和 Element</strong><br>作為參數傳遞在 <code>build(BuildContext context)</code> 裡面的 <code>BuildContext</code> ，事實上就是包裝 <code>Element</code> 的物件，因此每一個 <code>widget</code> 都有獨一無二的 <code>BuildContext</code> </p><hr><hr><p><strong>Conclusion</strong><br>我們可以得知 Flutter 如此高效是因為有這三棵樹，分別是 </p><ol><li><code>widget tree</code> 用來代表要使用的 UI 物件是什麼，再加上記錄一些簡單的狀態設定</li><li><code>element tree</code> 為兩棵樹間的代理人儲存相對應的每一層 <code>widget</code> 和 <code>renderObject</code> 的引用，用來比較彼此的相同或不同</li><li><code>rederobject tree</code> 為真實渲染到螢幕上的龐大昂貴的物件</li></ol><hr>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> iOS </tag>
            
            <tag> Flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>推播通知 Push Notification - 改變手機應用的技術</title>
      <link href="2020/03/11/%E6%8E%A8%E6%92%AD%E9%80%9A%E7%9F%A5-Push-Notification-%E6%94%B9%E8%AE%8A%E6%89%8B%E6%A9%9F%E6%87%89%E7%94%A8%E7%9A%84%E6%8A%80%E8%A1%93/"/>
      <url>2020/03/11/%E6%8E%A8%E6%92%AD%E9%80%9A%E7%9F%A5-Push-Notification-%E6%94%B9%E8%AE%8A%E6%89%8B%E6%A9%9F%E6%87%89%E7%94%A8%E7%9A%84%E6%8A%80%E8%A1%93/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>相信許多人起床的第一件事就是滑滑手機的通知，看一下有沒有新的 email 或訊息，甚至是購物平台的特價活動等等。最後再決定要不要打開那個應用程式或是一鍵清除。<em>所以如果這項技術不在我們的生活中，那我們的手機將會比宇宙還要安靜。</em> 透過伺服器主動發送訊息到客戶的手機，讓使用者可以及時地獲得各項服務的訊息通知。</p><span id="more"></span><h1 id="Firebase-Cloud-Messaging-介紹"><a href="#Firebase-Cloud-Messaging-介紹" class="headerlink" title="Firebase Cloud Messaging 介紹"></a>Firebase Cloud Messaging 介紹</h1><p><a href="https://firebase.google.com/docs/cloud-messaging/?gclid=CjwKCAjwmKLzBRBeEiwACCVihrLVkZCYLgGgoSq-qo4hRZP9u13ClyFbMIjpWQB234ZVU5W8YMjpmBoCOOQQAvD_BwE">Firebase Cloud Messaging</a> 簡稱 FCM ，它是一種跨平台的消息傳遞解決方案，可以讓服務免費的發送消息。當然數量也會有一定的限制。所以今天就是要使用 Node.js 來實作 FCM 發送消息的服務。</p><h1 id="在-Node-js-中配置-FCM"><a href="#在-Node-js-中配置-FCM" class="headerlink" title="在 Node.js 中配置 FCM"></a>在 Node.js 中配置 FCM</h1><h4 id="Step-1-安裝套件"><a href="#Step-1-安裝套件" class="headerlink" title="Step 1 安裝套件"></a>Step 1 安裝套件</h4><blockquote><p>npm install firebase-admin –save</p></blockquote><h4 id="Step-2-在專案中引入該套件"><a href="#Step-2-在專案中引入該套件" class="headerlink" title="Step 2 在專案中引入該套件"></a>Step 2 在專案中引入該套件</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> admin = <span class="built_in">require</span>(<span class="string">&#x27;firebase-admin&#x27;</span>);</span><br></pre></td></tr></table></figure><h4 id="Step-3-向-FCM-認證"><a href="#Step-3-向-FCM-認證" class="headerlink" title="Step 3 向 FCM 認證"></a>Step 3 向 FCM 認證</h4><p>將我們的 FCM 的 <a href="https://console.firebase.google.com/u/0/?pli=1">service account</a> 與我們的伺服器作認證連結</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">admin.initializeApp(&#123;</span><br><span class="line">  credential: admin.credential.applicationDefault(),</span><br><span class="line">  databaseURL: <span class="string">&#x27;https://&lt;DATABASE_NAME&gt;.firebaseio.com&#x27;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="傳送推播通知"><a href="#傳送推播通知" class="headerlink" title="傳送推播通知"></a>傳送推播通知</h1><p><img src="https://i.imgur.com/g7f4LIz.png"></p><p>經過以上的步驟我們的 Node.js 基本上就可以開始推播訊息給我們的用戶，但在這之前請確保手機的 App 已經設置好相關的 FCM sdk ，並將該用戶的 FCM token 傳送到後端並加以儲存。這是為了讓我們伺服器服務知道要推播通知給哪名使用者。</p><h3 id="對單一特定的手機裝置傳送-messages"><a href="#對單一特定的手機裝置傳送-messages" class="headerlink" title="對單一特定的手機裝置傳送 messages"></a>對單一特定的手機裝置傳送 messages</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 這個註冊的 token 是從手機端的 FCM SDKs 傳來的.</span></span><br><span class="line"><span class="keyword">var</span> registrationToken = <span class="string">&#x27;YOUR_REGISTRATION_TOKEN&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> message = &#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    score: <span class="string">&#x27;850&#x27;</span>,</span><br><span class="line">    time: <span class="string">&#x27;2:45&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  token: registrationToken</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 對這個已註冊 token 的手機裝置傳送訊息</span></span><br><span class="line">admin.messaging().send(message)</span><br><span class="line">  .then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// Response 是一個字串型別的 message ID.</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Successfully sent message:&#x27;</span>, response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Error sending message:&#x27;</span>, error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h3 id="對多個手機裝置傳送-messages"><a href="#對多個手機裝置傳送-messages" class="headerlink" title="對多個手機裝置傳送 messages"></a>對多個手機裝置傳送 messages</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以建立包含多達 100 個已註冊 token 的陣列(串列).</span></span><br><span class="line"><span class="comment">// 這些已註冊的 tokens 手機端的 FCM SDKs.</span></span><br><span class="line"><span class="keyword">const</span> registrationTokens = [</span><br><span class="line">  <span class="string">&#x27;YOUR_REGISTRATION_TOKEN_1&#x27;</span>,</span><br><span class="line">  <span class="comment">// …</span></span><br><span class="line">  <span class="string">&#x27;YOUR_REGISTRATION_TOKEN_N&#x27;</span>,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> message = &#123;</span><br><span class="line">  data: &#123;<span class="attr">score</span>: <span class="string">&#x27;850&#x27;</span>, <span class="attr">time</span>: <span class="string">&#x27;2:45&#x27;</span>&#125;,</span><br><span class="line">  tokens: registrationTokens,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">admin.messaging().sendMulticast(message)</span><br><span class="line">  .then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;response.successCount&#125;</span> messages were sent successfully`</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="對已訂閱特定主題-topics-的手機裝置傳送-messages"><a href="#對已訂閱特定主題-topics-的手機裝置傳送-messages" class="headerlink" title="對已訂閱特定主題 topics 的手機裝置傳送 messages"></a>對已訂閱特定主題 topics 的手機裝置傳送 messages</h3><p>在建立一個 <code>topic</code> 後，不是透過在手機裝置上訂閱該 <code>topic</code> 就是透過 <a href="https://firebase.google.com/docs/cloud-messaging/manage-topics?authuser=3">server API</a>.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以在 topic 名字前面選擇性地加上 &quot;/topics/&quot;.</span></span><br><span class="line"><span class="keyword">var</span> topic = <span class="string">&#x27;highScores&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> message = &#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    score: <span class="string">&#x27;850&#x27;</span>,</span><br><span class="line">    time: <span class="string">&#x27;2:45&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  topic: topic</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向已經訂閱該 topic 的手機裝置傳送訊息.</span></span><br><span class="line">admin.messaging().send(message)</span><br><span class="line">  .then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// Response 是一個字串型別的 message ID.</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Successfully sent message:&#x27;</span>, response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Error sending message:&#x27;</span>, error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>當然也有 <strong>條件主題</strong> 的功能，請查閱 <a href="https://firebase.google.com/docs/cloud-messaging/send-message?authuser=3#send_messages_to_topics">API</a></p><h3 id="批次傳送-messages"><a href="#批次傳送-messages" class="headerlink" title="批次傳送 messages"></a>批次傳送 messages</h3><p>可以將<strong>最多 100 條訊</strong>息組合在一起，然後在 <code>API</code> 呼叫中將他們一次送出去，與每次都為一條訊息發送 HTTP request 的效能上有顯著的提升. <code>e.g.</code> 當你需要同時傳送訊息到不同使用者上，而你主體的訊息內容只有些微的差異。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 建立一個最多包涵 100 條訊息的陣列(串列)。</span></span><br><span class="line"><span class="keyword">const</span> messages = [];</span><br><span class="line">messages.push(&#123;</span><br><span class="line">  notification: &#123;<span class="attr">title</span>: <span class="string">&#x27;Price drop&#x27;</span>, <span class="attr">body</span>: <span class="string">&#x27;5% off all electronics&#x27;</span>&#125;,</span><br><span class="line">  token: registrationToken,</span><br><span class="line">&#125;);</span><br><span class="line">messages.push(&#123;</span><br><span class="line">  notification: &#123;<span class="attr">title</span>: <span class="string">&#x27;Price drop&#x27;</span>, <span class="attr">body</span>: <span class="string">&#x27;2% off all books&#x27;</span>&#125;,</span><br><span class="line">  topic: <span class="string">&#x27;readers-club&#x27;</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">admin.messaging().sendAll(messages)</span><br><span class="line">  .then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response.successCount + <span class="string">&#x27; messages were sent successfully&#x27;</span>);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Node.js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Firebase Cloud Messaging </tag>
            
            <tag> Node.js </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
