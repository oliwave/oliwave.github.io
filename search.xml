<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Container 管理 (筆記 三) - kubernetes Component (二)</title>
      <link href="2020/12/09/title:%20Container%20%E7%AE%A1%E7%90%86%20(%E7%AD%86%E8%A8%98%20%E4%B8%89)%20-%20kubernetes%20/"/>
      <url>2020/12/09/title:%20Container%20%E7%AE%A1%E7%90%86%20(%E7%AD%86%E8%A8%98%20%E4%B8%89)%20-%20kubernetes%20/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上篇提到使用 Kubernetes 的一些基本元件。這次本篇主要在紀錄 Kubernetes 常用有關網路元件的介紹和如何使用：</p><ul><li>Service</li><li>Ingress</li></ul><span id="more"></span><h1 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h1><h2 id="Service-Discovery"><a href="#Service-Discovery" class="headerlink" title="Service Discovery"></a>Service Discovery</h2><p>Pod 重啟或重新部署都會產生新的 IP ，透過 Service 當作媒介，管理與監控這些 Pods 並對外暴露自己的 IP 供別人訪問存取。</p><img src="https://i.imgur.com/dmv1ReS.png" width="800" height="500" /><h2 id="Serivce-物件"><a href="#Serivce-物件" class="headerlink" title="Serivce 物件"></a>Serivce 物件</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubia</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="comment"># sessionAffinity: ClientIP # 根據需要來設定</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span> <span class="comment"># service 的 port</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">8080</span> <span class="comment"># service 會將封包轉送的 port</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">kubia</span></span><br></pre></td></tr></table></figure><img src="https://i.imgur.com/1fqweH8.png" width="700" height="400" /><hr><ol><li>在 cluster 中若需要 <strong><a href="https://kubernetes.io/docs/tasks/access-application-cluster/connecting-frontend-backend/"><code>pod-to-pod</code></a></strong> 請求中，<strong>請使用 Service 的 name 作為 hostname 而非 Pod ip 。</strong><ul><li> 因為你非但不能在 Pod 被建立以前知道他的 IP ，即使可以 Pod 隨時都有可能重啟或重新部署而改變 IP。</li><li><blockquote><p><a href="http://kubia/">http://kubia</a>.&lt;namespace&gt;</p></blockquote></li></ul></li><li><code>sessionAffinity</code>  只有 ClientIP 和 None 兩種模式，<strong>並沒有 cookie-based</strong> 。因為 K8s Service 是在 L4 而非 L7 所以只有 TCP 和 UDP</li></ol><hr><h3 id="多埠-Service-物件"><a href="#多埠-Service-物件" class="headerlink" title="多埠 Service 物件"></a>多埠 Service 物件</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubia</span></span><br><span class="line"><span class="attr">spec:</span> </span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span> <span class="comment"># 外部 80 轉送到內部 8080</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">8080</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">https</span> <span class="comment"># 443 轉送到 8443</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">443</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">8443</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">kubia</span></span><br></pre></td></tr></table></figure><h3 id="使用命名埠"><a href="#使用命名埠" class="headerlink" title="使用命名埠"></a>使用命名埠</h3><p><em>好處是萬一不是一個常見的 port 號，可以透過命名的方式讓結構更清晰</em></p><p><em>可以隨時更改底層 (Pod) 的 port 號而不會影響到上層的服務 (Service)</em></p><p>首先，先為 Pod 建立好 port 的名字</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">kubia</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span> <span class="comment"># 容器的 port 號 8080 命名為 http</span></span><br><span class="line">      <span class="attr">containerPort:</span> <span class="number">8080</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">https</span> <span class="comment"># 容器的 port 號 8443 命名為 https</span></span><br><span class="line">      <span class="attr">containerPort:</span> <span class="number">8443</span></span><br></pre></td></tr></table></figure><p>再來是為 Pod 建立好 Service </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="string">http</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">https</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">443</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="string">https</span></span><br></pre></td></tr></table></figure><hr><h4 id="為什麼-ping-不到-Service-的-IP"><a href="#為什麼-ping-不到-Service-的-IP" class="headerlink" title="為什麼 ping 不到 Service 的 IP ?"></a>為什麼 ping 不到 Service 的 IP ?</h4><img src="https://i.imgur.com/Vkv0jQB.png" width="500" height="500" /><ol><li><code>kube-proxy</code> 負責監控 Endpoints 的改變</li><li><code>kube-proxy</code> 如有服務訪問這組 IP 就會被 iptables 修改並且 forward 掉</li></ol><hr><h2 id="讓外部的用戶連線到-cluster-的-Service"><a href="#讓外部的用戶連線到-cluster-的-Service" class="headerlink" title="讓外部的用戶連線到 cluster 的 Service"></a>讓外部的用戶連線到 cluster 的 Service</h2><!-- ![](https://i.imgur.com/eonnWmB.png) --><img src="https://i.imgur.com/eonnWmB.png" width="700" height="500" /><p>讓外部來連線 Service 有以下幾種方式</p><ol><li><p>將 Service 的類型設為 <code>NodePort</code></p><ul><li>每一個在 cluster 裡面的 Node 都會開一個 Port ，然後把流量轉送到底層的 Service </li><li>該 Service 不僅可以透過 ClusterIP 和 Port 來訪問，也可以透過每個 Node 上的 Port</li></ul></li><li><p>將 Service 的類型設為 <code>LoadBalancer</code></p><ul><li>是 NodePort 的擴充版</li><li>是根據不同 cloud infrastructure 而定</li><li>用戶通過 load balancer 的 IP 來訪問 service</li></ul></li><li><p>建立 <code>Ingress</code> 資源，一種根本不同的機制，用於通過唯一 IP 公開多個服務</p><ul><li>它是在 Layer 7 上運作的</li></ul></li></ol><h3 id="NodePort"><a href="#NodePort" class="headerlink" title="NodePort"></a>NodePort</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubia-nodeport</span> </span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span> </span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span> <span class="comment"># 這是內部 cluster IP 的 port</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">8080</span> <span class="comment"># 這是 Pod 的 port</span></span><br><span class="line">    <span class="attr">nodePort:</span> <span class="number">30123</span> <span class="comment"># Service 可以從 Node 的 port 來被存取</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">kubia</span></span><br></pre></td></tr></table></figure><p>可以使用以下指令來檢查 NodePort Service </p><blockquote><p>kubectl get svc kubia-nodeport</p></blockquote><p><img src="https://i.imgur.com/WTTVeNc.png"></p><p>可以看到 <code>EXTERNAL-IP</code> 是 <code>&lt;nodes&gt;</code> ，也就是說該 Service 可以在每一個 node 上透過 30123 port 被存取。</p><img src="https://i.imgur.com/frEDH1l.png" width="600" height="500" /><!-- ![](https://i.imgur.com/frEDH1l.png) --><h3 id="LoadBalancer"><a href="#LoadBalancer" class="headerlink" title="LoadBalancer"></a>LoadBalancer</h3><ul><li><strong>用在公有雲上</strong>， cloud providers 通常會支援該模式。</li><li>與 NodePort 不同，它是透過唯一的 Public IP 來做存取。</li></ul><p><img src="https://i.imgur.com/rjN3ViF.png" width="600" height="500" /></br></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#...</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">LoadBalancer</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span> <span class="comment"># 這是內部 cluster IP 的 port</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">8080</span> <span class="comment"># 這是 Pod 的 port</span></span><br><span class="line"><span class="comment">#...    </span></span><br></pre></td></tr></table></figure><h3 id="Ingress"><a href="#Ingress" class="headerlink" title="Ingress"></a>Ingress</h3><p>單純定義一個 Service 並讓 Ingress 指向它</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#...</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubia</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span> <span class="comment"># service 的 port</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">8080</span> <span class="comment"># service 會將封包轉送的 port</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">kubia</span></span><br></pre></td></tr></table></figure><h2 id="連接-cluster-外部的-Service"><a href="#連接-cluster-外部的-Service" class="headerlink" title="連接 cluster 外部的 Service"></a>連接 cluster 外部的 Service</h2><h3 id="Service-與-Endpoints-的關係"><a href="#Service-與-Endpoints-的關係" class="headerlink" title="Service 與 Endpoints 的關係"></a>Service 與 Endpoints 的關係</h3><ul><li>Service 和 Pod 並不是直接有所連結的，而是有一個叫做 <strong>Endpoints</strong> 的資源在中間。</li><li><strong>Endpoints 資源(複數)是一組一組可供 Service 做 loadbalance 的 Pod socket 清單</strong></li></ul><blockquote><p>kubectl describe svc kubia</p></blockquote><p><img src="https://i.imgur.com/XfkaV9c.png"></p><blockquote><p>kubectl get endpoints kubia</p></blockquote><p><img src="https://i.imgur.com/1HNBfID.png"></p><hr><ol><li>如果 Service 有設定 Pod 的 label selector 就會自動產生 Endpoints 物件，<strong>並且幫你自動維護</strong>。</li><li>反之，必須自己建立 Endpoints 物件，<strong>並且必須與 Service 同名</strong>。</li></ol><hr><h3 id="自己設定-Service-Endpoints-的時機：連線到外部網路的服務"><a href="#自己設定-Service-Endpoints-的時機：連線到外部網路的服務" class="headerlink" title="自己設定 Service Endpoints 的時機：連線到外部網路的服務"></a>自己設定 Service Endpoints 的時機：連線到外部網路的服務</h3><ol><li><p>創建一個沒有 selector 的 Service</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">google-map</span> <span class="comment"># Service 的名字必須和 Endpoints 一樣</span></span><br><span class="line"><span class="attr">spec:</span>  <span class="comment"># 無需定義 selector</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure></li><li><p> 為沒有 selector 的 Service 創建 Endpoints</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Endpoints</span> </span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">google-map</span> <span class="comment"># Endpoints 的名字必須和 Service 的一樣</span></span><br><span class="line"><span class="attr">subsets:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">addresses:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">ip:</span> <span class="number">11.11</span><span class="number">.11</span><span class="number">.11</span> <span class="comment"># Service 將連接轉發到的端點的 IP</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">ip:</span> <span class="number">22.22</span><span class="number">.22</span><span class="number">.22</span> </span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure></li></ol><p><img src="https://i.imgur.com/ejnt4Nc.png" width="800" height="400" /></br></p><!-- ![](https://i.imgur.com/ejnt4Nc.png) --><p>Service 和 Endpoints 建立起來後，就可以讓 Pods 透過 Service 存取具有兩個外部端點。</p><hr><h3 id="連線到外部網路服務的另一種方式：ExternalName-Service"><a href="#連線到外部網路服務的另一種方式：ExternalName-Service" class="headerlink" title="連線到外部網路服務的另一種方式：ExternalName Service"></a>連線到外部網路服務的另一種方式：ExternalName Service</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">google-map</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">ExternalName</span> <span class="comment"># Service 的類型為 ExternalName</span></span><br><span class="line">  <span class="attr">externalName:</span> <span class="string">maps.googleapis.com</span> <span class="comment"># 真實服務的 FQDN</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><ul><li>Pod 呼叫外部的 API 就使用 <code>http://google-map</code></li><li>不影響 Pod 的情況下，在 ExternalName Service 上改變存取的外部服務的網址</li></ul><hr><h2 id="Ingress-1"><a href="#Ingress-1" class="headerlink" title="Ingress"></a>Ingress</h2><h3 id="為什麼一定需要-Ingress"><a href="#為什麼一定需要-Ingress" class="headerlink" title="為什麼一定需要 Ingress ?"></a>為什麼一定需要 Ingress ?</h3><p>每一個 LoadBalancer Service 都需要有自己的 IP，而 Ingress 只需要一個 IP。</p><p><img src="https://i.imgur.com/vaXiJZd.png"></p><p><strong>Ingress 是在 Layer 7 上面運作，所以可以提供比 Service 更多的功能。</strong></p><h3 id="Ingress-Controller"><a href="#Ingress-Controller" class="headerlink" title="Ingress Controller"></a>Ingress Controller</h3><p>必須記得 K8s cluster 中必須要有 Ingress controller 才可以讓 Ingress 正常運作。不同的 K8s 環境在 controller 實作上也不同。</p><h3 id="創建-Ingress"><a href="#創建-Ingress" class="headerlink" title="創建 Ingress"></a>創建 Ingress</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubia</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">kubia.example.com</span></span><br><span class="line">    <span class="attr">http:</span> </span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/</span> </span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">serviceName:</span> <span class="string">kubia-nodeport</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="number">80</span></span><br><span class="line">  <span class="comment">#     - path: /foo</span></span><br><span class="line">  <span class="comment">#       backend:</span></span><br><span class="line">  <span class="comment">#         serviceName: bar</span></span><br><span class="line">  <span class="comment">#         servicePort: 80</span></span><br><span class="line">  <span class="comment"># - host: bar.example.com </span></span><br><span class="line">  <span class="comment">#     http:</span></span><br><span class="line">  <span class="comment">#       paths:</span></span><br><span class="line">  <span class="comment">#         - path: /</span></span><br><span class="line">  <span class="comment">#           backend:</span></span><br><span class="line">  <span class="comment">#             serviceName: bar</span></span><br><span class="line">  <span class="comment">#             servicePort: 80</span></span><br></pre></td></tr></table></figure><!-- :::warning> FIXEME: 1.幹嘛還需要 ingress 如果有 nodeport 了 2.GKE 還需要用 ingress 嗎在 GKE 中，要求 service 必須為 NodePort ，但在 k8s 系統中是沒有這個要求的::: --><p>一個 client 向 K8s cluster 請求的基本流程</p><!-- ![](https://i.imgur.com/g8e8Gft.png) --><img src="https://i.imgur.com/g8e8Gft.png" width="800" height="400" />]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Microservice </tag>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Container 管理 (筆記 二) - kubernetes Component (一)</title>
      <link href="2020/11/09/Container%20%E7%AE%A1%E7%90%86%20(%E7%AD%86%E8%A8%98%20%E4%BA%8C)%20-%20Kubernetes/"/>
      <url>2020/11/09/Container%20%E7%AE%A1%E7%90%86%20(%E7%AD%86%E8%A8%98%20%E4%BA%8C)%20-%20Kubernetes/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上篇提到使用 Kubernetes 情境的前因後果以及它的基礎架構。這次本篇主要在紀錄 Kubernetes 常用的部分元件的介紹和如何使用：</p><ul><li>Pod</li><li>Label</li><li>ReplicaSet</li><li>DaemonSet</li></ul><span id="more"></span><h1 id="kubernetes-Component"><a href="#kubernetes-Component" class="headerlink" title="kubernetes Component"></a>kubernetes Component</h1><h2 id="k8s-物件的概念"><a href="#k8s-物件的概念" class="headerlink" title="k8s 物件的概念"></a>k8s 物件的概念</h2><p>k8s 常見的物件像是 <code>Pod</code>、<code>Service</code>、<code>deployment</code>、<code>ingress</code> 等等</p><p><strong>使用 Kubernetes API 時，是以 JSON 或 YAML 檔案來定義物件。</strong></p><!-- - 這些檔案不是由伺服器因應 query 的請求而返回，又或是作為請求 api 的一部分傳到伺服器上。 --><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># This&#x27;s a yaml file to describe the spec and state of Pod objects.</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">kubia-manual</span></span><br><span class="line">    <span class="attr">labels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">kubia</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">    <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">oliwave/kubia</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">kubia</span></span><br><span class="line">      <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8080</span></span><br><span class="line">        <span class="attr">protocol:</span> <span class="string">TCP</span></span><br></pre></td></tr></table></figure><h2 id="k8s-物件和-RESTful-API-的關係"><a href="#k8s-物件和-RESTful-API-的關係" class="headerlink" title="k8s 物件和 RESTful API 的關係"></a>k8s 物件和 RESTful API 的關係</h2><ul><li>任何資源在 k8s 當中都可以用 <strong>RESTful 的 <a href="https://dev.to/flippedcoding/what-is-the-difference-between-a-uri-and-a-url-4455">URI</a> 來表示</strong>。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;your-k8s.com&#x2F;api&#x2F;v1&#x2F;namespaces&#x2F;default&#x2F;pods&#x2F;my-pod</span><br></pre></td></tr></table></figure></li><li>這些資源在 k8s 當中都叫做 Kubernetes objects 。</li><li>每一個 kubernetes objects 都存在 <strong>唯一的 HTTP/HTTPS 路徑</strong>。</li></ul><p>取得 Kubernetes objects 最基本的 kubectl 指令是 <strong>get</strong> </p><blockquote><p>kubectl get &lt;resource-name&gt;</p></blockquote><p>列出在目前 namespaces 底下的所有資源，然而若想要取得特定資源</p><blockquote><p>kubectl get &lt;resource-name&gt; &lt;obj-name&gt;</p></blockquote><p>想要知道該物件的詳細資訊</p><blockquote><p>kubectl describe &lt;resource-name&gt; &lt;obj-name&gt;</p></blockquote><hr><h3 id="o-參數的意義"><a href="#o-參數的意義" class="headerlink" title="-o 參數的意義"></a>-o 參數的意義</h3><p>在預設的情況下， kubectl 的返回結果是 human-readable ，但這會導致許多詳細的資訊被省略掉。如果想要得到完整的 <strong>物件</strong> 可以加上 -o 參數並指定想要的格式</p><blockquote><p>-o json/yaml</p></blockquote><p>更進階的做法還可以從返回的物件中指定想要看到的 field</p><blockquote><p>kubectl get pods my-pod -o jsonpath –template={.status.podIP}</p></blockquote><hr><h3 id="Creating-Updating-物件"><a href="#Creating-Updating-物件" class="headerlink" title="Creating, Updating 物件"></a>Creating, Updating 物件</h3><h4 id="範例"><a href="#範例" class="headerlink" title="範例"></a>範例</h4><p>假設有一個簡單的物件在 <code>obj.yaml</code> 中定義好了。可以透過 kubectl 在 Kubernetes 中 <strong>創建和更新</strong> 該物件</p><blockquote><p>kubectl apply -f obj.yaml</p></blockquote><p><strong>每個物件會有 metadata 這個欄位，用以定義物件唯一的名字</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#...</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">inventory</span></span><br><span class="line"><span class="comment">#...</span></span><br></pre></td></tr></table></figure><h1 id="Namespaces"><a href="#Namespaces" class="headerlink" title="Namespaces"></a>Namespaces</h1><p>Kubernetes 支持由同一 physical cluster 支持的多個 virtual clusters。這些  virtual clusters 稱為 <strong>Namespaces</strong>。</p><p><img src="https://i.imgur.com/A16s2k9.png"></p><p>namespaces 提供了名稱範圍。資源名稱在名稱空間內必須唯一，但在各個名稱空間之間是不用的。namespaces 彼此是平行的關係，</p><p><strong>物件的名字在一個 namespace 底下是唯一的</strong></p><ul><li><code>namespaces</code> 用來組織在叢集中的 <strong>物件</strong></li><li>可以把每一個 <em><code>namespaces</code></em> 都想像成一個 <strong>資料夾</strong> 管理自己的 <strong>物件</strong></li><li><code>kubectl</code> 預設是和 <code>default namespaces</code> 互動</li><li>如果想列出叢集中所有的 <code>pods</code> ，可以用 <code>--all-namespaces</code> 作為參數</li><li>不同的使用者應該有不同的 <code>namespaces</code> ，也需要有權限的管理</li></ul><h4 id="創建-Namespace"><a href="#創建-Namespace" class="headerlink" title="創建 Namespace"></a>創建 Namespace</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Namespace</span> <span class="comment"># 資源的類型</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">custom-namespace</span> <span class="comment"># Namespace 的名字</span></span><br></pre></td></tr></table></figure><p>在不同的 <code>namespace</code> 創建資源</p><blockquote><p>kubectl create -f kubia-manual.yaml -n custom-namespace</p></blockquote><h1 id="Pods"><a href="#Pods" class="headerlink" title="Pods"></a>Pods</h1><h2 id="Pod-基本概念"><a href="#Pod-基本概念" class="headerlink" title="Pod 基本概念"></a>Pod 基本概念</h2><ol><li>K8s 將多個 container 變成一組單位 <code>Pod</code> (Pod 有一群鯨魚的意思)<!-- 2. Pod 代表一個在相同環境底下執行的 application containers 和 volume 的集合 **// rephrase** --></li><li>Pod 是 K8s 中可部署的最小單位，也就是所有在 Pod 裡的 containers 都運行在同一個 worker node 上面。</li><li><strong>每一個在 Pod 裡面的 container 都擁有自己的 cgroup ，但卻共用一定數量的 namespaces</strong></li><li>應用程式在同個 Pod 中共享同個 <code>Network</code> 、 <code>UTS</code> (hostname)、 <code>IPC</code> namespaces ，因此可以用 <code>http://localhost:\&lt;port_num&gt;</code> 來彼此溝通 (IPC)。相反的應用程式在不同的 Pod 是隔離的，所以有不同的 IP 、 hostname 等等。</li></ol><hr><h2 id="Container-的概念"><a href="#Container-的概念" class="headerlink" title="Container 的概念"></a>Container 的概念</h2><p>使用 Linux 的兩個技術</p><ul><li><strong>Namespaces</strong>  確保每一個 process 都是由自己的觀點去看整個系統 (files, processes, network interfaces, hostname, and so on) <strong>軟體</strong></li></ul><ul><li><strong>Cgroups</strong> 限制每一個 process 可以使用的資源 (CPU, memory, network bandwidth, and so on) <strong>硬體</strong></li></ul><p>有許多種 Namespaces 而每一種都是在隔離不同種的資源</p><hr><h2 id="Pod-IP"><a href="#Pod-IP" class="headerlink" title="Pod IP"></a>Pod IP</h2><p>對 K8s 來說，不管 Pod 在哪一個 Node 上都可以把它們想像成在同一個 LAN 底下。因此彼此是可以訪問對方的，這是透過 <strong>CNI</strong> (overlay network) 來實現的。</p><p><img src="https://i.imgur.com/uBwYrHV.png"></p><!-- **在同一個 Pod 底下的 containers 就像一台實體主機或虛擬機上跑一些 processes 一樣** --><h2 id="如何創建一個-Pod"><a href="#如何創建一個-Pod" class="headerlink" title="如何創建一個 Pod"></a>如何創建一個 Pod</h2><p>事實上可以透過 kubectl 用以下幾種 K8s 提供的方式來創造物件</p><ul><li><code>Imperative command</code> 立即指令（<strong>不建議使用</strong>）<ul><li><blockquote><p>kubectl run kuard –generator=run-pod/v1 –image=gcr.io/kuar-demo/kuard-amd64:blue</p></blockquote></li></ul></li><li><code>Declarative configuation</code> =&gt; <strong>撰寫 Pod manifest</strong><ul><li><blockquote><p>kubectl apply -f pod.yaml</p></blockquote></li></ul></li></ul><ol><li>撰寫簡易的 Pod Manifest</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kuard</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">gcr.io/kuar-demo/kuard-amd64:blue</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">kuard</span></span><br><span class="line">      <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8080</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">          <span class="attr">protocol:</span> <span class="string">TCP</span></span><br></pre></td></tr></table></figure><hr><h3 id="什麼是-Pod-Manifest"><a href="#什麼是-Pod-Manifest" class="headerlink" title="什麼是 Pod Manifest"></a>什麼是 Pod Manifest</h3><ul><li>Pod Manifest 就只是一個用 json 或 yaml 格式來描述 <strong>Pod 物件</strong> 的文字檔案</li><li>該文件描述 Pod 的 <strong>ideal state</strong> ，因此<strong>這是一種 declarative configuration 而不是 imperative configuration</strong></li><li>事實上撰寫 Pod Manifest (或其他 K8s 物件) 是比較推薦的<ul><li>當 source code 在維護</li><li>更容易閱讀</li></ul></li></ul><hr><ol start="2"><li><p>把撰寫好的 Pod Manifest 透過 kubectl 丟到 K8s API server</p><ul><li><blockquote><p>kubectl apply -f kuard-pod.yaml</p></blockquote></li></ul></li><li><p>K8s API server 會做兩件事:</p><ol><li>透過 <strong>Kube Scheduler</strong> 會決定要放在哪個 worker node 上。</li><li><strong>Kubelet</strong> 屆時會負責把相對應寫在 Pod manifest 裡的 container 都運行起來，並且監控。</li></ol></li></ol><p>以上都步驟都完成後，可以查看所有 Pod 的狀況</p><p><code>kubectl get pods</code></p><p><img src="https://i.imgur.com/i29gYZY.png"></p><p>或是檢查單一 Pod 的詳細資訊</p><p><code>kubectl describe pods kuard</code></p><!-- > FIEXME: 調整 header --><h2 id="終止-pod"><a href="#終止-pod" class="headerlink" title="終止 pod"></a>終止 pod</h2><p><code>kubectl delete pods kuard</code></p><p>:::info</p><h3 id="還有許多可以對-Pod-做的設定…"><a href="#還有許多可以對-Pod-做的設定…" class="headerlink" title="還有許多可以對 Pod 做的設定…"></a>還有許多可以對 Pod 做的設定…</h3><h4 id="Grace-Period"><a href="#Grace-Period" class="headerlink" title="Grace Period"></a>Grace Period</h4><p>事實上當我們刪除一個 Pod 時 K8s 會做以下事情</p><ol><li>讓 Pod 拒絕接收新的 request，並消化當前還有的 request</li><li>在預設時間 30 秒過後才把 Pod 刪除掉</li></ol><p>以上的 30 秒就是所謂的 <strong>Grace period</strong> ，這麼做是為了確保服務的<strong>可靠性</strong>。我們不希望有任何請求是因為要刪除 Pod 而無法回應到的</p><h4 id="Health-Check"><a href="#Health-Check" class="headerlink" title="Health Check"></a>Health Check</h4><p>最簡易的 health check 就是 <strong>process health check</strong> 。也就是直接判斷該程序是否還繼續執行著。但這會有一個很大的問題就是萬一程序進入 dead lock ，事實上該程序仍然運行的但是卻無法再提供服務了。</p><p>因此在 K8s 引進了幾種方法來解決</p><h5 id="Liveness-Probe"><a href="#Liveness-Probe" class="headerlink" title="Liveness Probe"></a>Liveness Probe</h5><p>也<strong>就是執行一個任務，如果通過了他就還健在</strong>。常見的就是發 http request 檢查在 Pod 裡的 container 是否健康～<br><br></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kuard</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">gcr.io/kuar-demo/kuard-amd64:blue</span> </span><br><span class="line">      <span class="attr">name:</span> <span class="string">kuard</span></span><br><span class="line">      <span class="attr">livenessProbe:</span></span><br><span class="line">        <span class="attr">httpGet:</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">/healthy</span> <span class="comment"># 測試該容器是否健康的請求</span></span><br><span class="line">          <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">        <span class="attr">initialDelaySeconds:</span> <span class="number">5</span> <span class="comment"># 在 Pod 被初始化後的 5 秒才開始測試</span></span><br><span class="line">        <span class="attr">timeoutSeconds:</span> <span class="number">1</span> <span class="comment"># 限時 1 秒回應</span></span><br><span class="line">        <span class="attr">periodSeconds:</span> <span class="number">10</span> <span class="comment"># 每 10 秒一次</span></span><br><span class="line">        <span class="attr">failureThreshold:</span> <span class="number">3</span> <span class="comment"># 超過三次失敗就重起該 container</span></span><br><span class="line">      <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8080</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">            <span class="attr">protocol:</span> <span class="string">TCP</span></span><br></pre></td></tr></table></figure><h5 id="Readiness-Probe"><a href="#Readiness-Probe" class="headerlink" title="Readiness Probe"></a>Readiness Probe</h5><p>readiness probe 和 liveness probe 最大的不一樣就是 liveness probe 確認應用程式是否正確執行，而它則是 <strong>檢查該應用程式是不是已經準備好可以開始服務了</strong>。</p><h5 id="其他的-K8s-所提供的-Health-Check"><a href="#其他的-K8s-所提供的-Health-Check" class="headerlink" title="其他的 K8s 所提供的 Health Check"></a>其他的 K8s 所提供的 Health Check</h5><p>除了 HTTP 以外，還有 <strong>tcpSocket health checks</strong> 或是讓容器執行一段 script 來檢查。這麼做是因為不是每一個服務都是 http-base appliction.</p><hr><hr><h5 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h5><p><strong>以下都是不建議直接使用 kubectl 去操作的</strong> (違反 declarative configuration 精神)</p><p>有更適當的工具或方法去完成這些任務。</p><ol><li>取得 Pod 的 Logs (fluentd and elasticsearch)</li><li>在 container 裡面執行指令</li><li>從 container 裡面複製檔案到外面，反之亦然</li></ol><hr><h4 id="Resource-Management"><a href="#Resource-Management" class="headerlink" title="Resource Management"></a>Resource Management</h4><p>Pod 在資源（cpu, mem, gpu）的請求上在 K8s 有兩種方式</p><ul><li><strong>minimum</strong> 該容器最少需要多少該種類型的資源 (情況允許，可以多給)</li><li><strong>limit</strong> 該容器最多可以擁有該種類型的資源</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kuard</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">gcr.io/kuar-demo/kuard-amd64:blue</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">kuard</span></span><br><span class="line">        <span class="attr">resources:</span></span><br><span class="line">          <span class="attr">requests:</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="string">&quot;500m&quot;</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">&quot;128Mi&quot;</span></span><br><span class="line">          <span class="attr">limits:</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="string">&quot;1000m&quot;</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">&quot;256Mi&quot;</span></span><br><span class="line">      <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8080</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">            <span class="attr">protocol:</span> <span class="string">TCP</span></span><br></pre></td></tr></table></figure><ol><li><strong>記住資源的請求是以 container 為單位，因為不同服務需要的資源種類和數量都不一樣</strong></li><li><strong>一個 Pod 所請求的資源就是其所有 containers 資源請求的總和</strong></li><li><strong>記憶體與 CPU 資源的分配不一樣，因為記憶體一旦分配給一個程序就不能再收回。因此當系統消耗完記憶體的資源時，就會把取得過多的 contaienr 重啟以達重新分配記憶體資源</strong></li></ol><h4 id="在-Pod-中不同類型的-volume"><a href="#在-Pod-中不同類型的-volume" class="headerlink" title="在 Pod 中不同類型的 volume"></a>在 Pod 中不同類型的 volume</h4><ul><li>生命週期與 Pod 相同的 volume (<strong>emptyDir</strong>)<ul><li>For Communication/synchronization <ul><li>容器間可以共用一些資料</li></ul></li><li>For Cache<ul><li>有時容器需要或被重啟，那就可以緩衝一些運算昂貴的資料</li></ul></li></ul></li><li>長期維持的 Persistent volume Persistent<ul><li>不管是 private 或 public 的 provider ， k8s 都有提供 api</li><li>e.g. NFS, iSCSI, Amazon’s Elastic Block Store, Azure’s Files and Disk Storage,  Google’s Persistent Disk <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&quot;kuard-data&quot;</span></span><br><span class="line">    <span class="attr">nfs:</span></span><br><span class="line">      <span class="attr">server:</span> <span class="string">my.nfs.server.local</span> </span><br><span class="line">      <span class="attr">path:</span> <span class="string">&quot;/exports&quot;</span></span><br></pre></td></tr></table></figure></li><li>Mounting the host filesystem (hostPath)<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kuard</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&quot;kuard-data&quot;</span> </span><br><span class="line">      <span class="attr">hostPath:</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">&quot;/var/lib/kuard&quot;</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">gcr.io/kuar-demo/kuard-amd64:blue</span> </span><br><span class="line">      <span class="attr">name:</span> <span class="string">kuard</span></span><br><span class="line">      <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">&quot;/data&quot;</span> </span><br><span class="line">          <span class="attr">name:</span> <span class="string">&quot;kuard-data&quot;</span></span><br><span class="line">      <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8080</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">          <span class="attr">protocol:</span> <span class="string">TCP</span>      </span><br></pre></td></tr></table></figure></li></ul></li></ul><p><em>不像 docker ，沒有簡單的方法～</em></p><h1 id="Labels"><a href="#Labels" class="headerlink" title="Labels"></a>Labels</h1><ul><li>Labels 是 <strong>鍵值對</strong></li><li>Labels 提供了為 <strong>物件分組</strong> 的基礎（該物件可以是 pod, replicaSet …）</li></ul><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>Labels 提供一群物件可被識別的標記</strong>，這為之後分組、操作、查看等動作帶來方便。</p><p>在 K8s 中物件要尋找或參考到其他物件的時候就需要用到 selector 。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ReplicaSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubia</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span> <span class="comment"># ReplicaSet 用 label 來尋找它管理的物件</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">template:</span> <span class="comment"># PodTemplate </span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span> <span class="comment"># 將 pod 貼上 `app: test` 這個 label</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">test</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">kubia</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">luksa/kubia</span></span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/mSLyrq7.png" width="500" height="500" /></br></p><hr><p><code>Selector</code> 底下分兩種方式來參考到含有該 label 的物件:</p><ol><li><code>matchLabels</code> 和 <code>matchExpressions</code><ul><li><strong>只有 <code>Job</code>、<code>Deployment</code>、<code>ReplicaSet</code> 還有 <code>DaemonSet</code> 有支援</strong><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">selector:</span></span><br><span class="line">  <span class="attr">matchLabels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">tier:</span> <span class="string">frontend</span></span><br><span class="line"> <span class="comment"># or</span></span><br><span class="line"> <span class="comment">#matchExpressions:</span></span><br><span class="line"> <span class="comment">#- key: app # 鍵 必須為 &#x27;app&#x27;</span></span><br><span class="line"> <span class="comment">#  operator: In # 值 必須為 &#x27;kubia&#x27;</span></span><br><span class="line"> <span class="comment">#  values:</span></span><br><span class="line"> <span class="comment">#    - kubia</span></span><br></pre></td></tr></table></figure></li></ul></li><li>什麼都不加，直接放 label<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">selector:</span></span><br><span class="line">  <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">tier:</span> <span class="string">frontend</span></span><br></pre></td></tr></table></figure></li></ol><p><a href="https://medium.com/@zwhitchcox/matchlabels-labels-and-selectors-explained-in-detail-for-beginners-d421bdd05362">(matchLabels, labels, and selectors 差別)</a></p><hr><h1 id="ReplicaSet-amp-DaemonSet"><a href="#ReplicaSet-amp-DaemonSet" class="headerlink" title="ReplicaSet &amp; DaemonSet"></a>ReplicaSet &amp; DaemonSet</h1><!-- ![](https://i.imgur.com/7cq15KY.png) --><img src="https://i.imgur.com/7cq15KY.png" width="800" height="400" /><ul><li><p><strong>RS</strong> 定義一個 Pod 數量讓他們隨機散佈在 K8s cluster 中</p></li><li><p><strong>DS</strong> <strong>特殊需求</strong> ，要讓 cluster 中的每個 worker node 都有一個該服務的 Pod 。</p><ul><li>例如，像是 log collector 或是 memory monitor 的程式需要在每個節點上。</li><li>在 K8s 系統中 kube-proxy Pod 也是運行在每一個節點上。</li></ul></li></ul><h2 id="ReplicaSet"><a href="#ReplicaSet" class="headerlink" title="ReplicaSet"></a>ReplicaSet</h2><ol><li>通常不會直接使用 ReplicaSet 而是用更高層次的 Deployment<!-- 2. 基本上兩者功能都相同，但是在 label selector 上 ReplicaSet **可以同時比較兩個 labels 以上，還有直接判斷是否有該 key 而不管它的 value (e.g. env=\*)** --></li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ReplicaSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubia</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">kubia</span></span><br><span class="line">    <span class="comment">#matchExpressions:</span></span><br><span class="line">    <span class="comment">#- key: app # 鍵 必須為 &#x27;app&#x27;</span></span><br><span class="line">    <span class="comment">#  operator: In # 值 必須為 &#x27;kubia&#x27;</span></span><br><span class="line">    <span class="comment">#  values:</span></span><br><span class="line">    <span class="comment">#    - kubia</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">kubia</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">kubia</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">luksa/kubia</span></span><br></pre></td></tr></table></figure><p>詳情可見 <a href="https://hackmd.io/exfgC8MzSfqKsJgkWIpkJA?both#Labels-Selectors">label selector</a></p><h2 id="DaemonSet"><a href="#DaemonSet" class="headerlink" title="DaemonSet"></a>DaemonSet</h2><p><strong>DS 只會在每一個 Node 上執行一個 Pod</strong></p><p>因此 DaemonSet 不需要透過 K8s scheduler 來安排 Pod 在哪個節點上</p><h3 id="將-Pod-部署到特定的節點上"><a href="#將-Pod-部署到特定的節點上" class="headerlink" title="將 Pod 部署到特定的節點上"></a>將 Pod 部署到特定的節點上</h3><img src="https://i.imgur.com/ksxUhIn.png" width="800" height="400" /><!-- ![](https://i.imgur.com/ksxUhIn.png) --><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">DaemonSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ssd-monitor</span> </span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">ssd-monitor</span> <span class="comment"># 管理 label 為 `app:ssd-monitor` 的 Pod</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">ssd-monitor</span> </span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">nodeSelector:</span> <span class="comment"># PodSpec 定義的 field</span></span><br><span class="line">        <span class="attr">disk:</span> <span class="string">ssd</span> <span class="comment"># 把 Pod 部署到有 ssd 的節點上</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">main</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">luksa/ssd-monitor</span></span><br></pre></td></tr></table></figure><hr><ul><li><em>如果 nodeSelector 沒有成功找到符合的節點，就不會創建 Pod</em></li><li><em>刪除 RS DS 都會連帶刪除旗下的 Pods</em></li></ul><p>daemonset 也可以用 label selector 部署 pod 到特定的 node 上</p><hr>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Microservice </tag>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Container 管理 (筆記 一) - Monolithic to Microservice</title>
      <link href="2020/10/09/Container%20%E7%AE%A1%E7%90%86%20(%E4%B8%80)%20-%20Monolithic%20to%20Microservice/"/>
      <url>2020/10/09/Container%20%E7%AE%A1%E7%90%86%20(%E4%B8%80)%20-%20Monolithic%20to%20Microservice/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在玩轉 Kubernetes 這個炫砲的技術之前，我們必須要先瞭解它到底在解決什麼樣的問題以及整個來龍去脈。該文章主要先探討 Monlithic 作為歷史背景下常用的開發模式，一直到使用 Microservice 時遇到的處境以及相對應工具的搭配，來呈現在應用程式微服務化的情境底下如何管理大量的微服務。系列文章是 <a href="https://www.tenlong.com.tw/products/9781617293726">Kubernetes in action</a> 讀後的筆記文。</p><span id="more"></span><h3 id="Monolithic-的缺點"><a href="#Monolithic-的缺點" class="headerlink" title="Monolithic 的缺點"></a>Monolithic 的缺點</h3><ol><li>隨時間而變肥大且複雜，軟體難以重構。在除錯時也難以尋找。</li><li>不能依據不同服務的流量需求來 <strong>水平擴展</strong> ，而是一次部署整體支應用程式造成不必要的資源成本增加。</li></ol><h3 id="Microservice-的優點"><a href="#Microservice-的優點" class="headerlink" title="Microservice 的優點"></a>Microservice 的優點</h3><ol><li>開發上的可以做到良好的<strong>解隅 (Decouple)</strong></li><li>擁有水平擴展的能力 (依然需要看情境)</li><li>不同的微服務可以獨立維護部署</li></ol><img src="https://i.imgur.com/enSwKWw.png" width="800" height="400" /><img src="https://i.imgur.com/fSUyZRB.png" width="800" height="400" /><h2 id="困難點"><a href="#困難點" class="headerlink" title="困難點"></a>困難點</h2><ul><li><p>😂 重新抽象軟體架構</p></li><li><p>😂 <strong>API 要變成 stateless</strong> (*註解ㄧ)</p></li><li><p>😍 由於系統變得龐大且複雜，所以在除錯上會更加困難 <a href="https://zipkin.io/">Zipkin</a></p></li><li><p>😍😎 當有大量的微服務 <strong>相互依賴</strong> 時會讓你要去決定誰去要一起被部署</p></li><li><p>😎 微服務造成環境的多樣性更高，在開發和部署環境上更不容易維護</p></li><li><p>😎 環境需求的不同，程式想要不同版本的 shared libs</p></li></ul><p>註解一：</p><ol><li>當你的服務不需要在內部維持請求之間的狀態時就是 <strong>stateless service</strong> ，反之就是 <strong>stateful service</strong> (<strong>需要開 sticky session</strong>)。</li><li>微服務應該將狀態資訊儲存在外部而非內部，這才有利於服務的擴展。</li></ol><p><a href="https://stackoverflow.com/questions/58696684/stateless-vs-stateful-microservices">stateful vs stateless</a></p><h2 id="解決"><a href="#解決" class="headerlink" title="解決"></a>解決</h2><ul><li><p>😂 依賴軟體團隊的經驗設計</p></li><li><p>😍 服務的<a href="https://www.fiorano.com/blogs/microservices">顆粒度(Granularity)</a>應該以獨立的業務邏輯來解決之間因 <strong>相互依賴</strong> 導致 <strong>除錯困難</strong> 的問題</p></li><li><p>😎 <strong>We ease the pain with the help of docker and kubernetes.</strong></p></li></ul><h1 id="介紹"><a href="#介紹" class="headerlink" title="介紹"></a>介紹</h1><p><strong>因應大量容器部署管理的困難，所以才需要有一個容器管理工具來解決</strong> (e.g. 某公司測試用 8000 個 container)</p><h2 id="Container-management-solutions"><a href="#Container-management-solutions" class="headerlink" title="Container management solutions"></a>Container management solutions</h2><ul><li><strong>docker-compose</strong> <ul><li>適用在 <strong>單節點</strong> 的環境上，可以快速部署多個容器。</li></ul></li><li><strong>openshift</strong> <ul><li><strong>now base on kubernetes</strong></li><li>red hat cloud 較不有名<img src="https://i.imgur.com/JegIerL.png" width="450" height="450" /></li></ul></li><li><strong>kubernetes</strong><ul><li>在 public cloud 得到最完整的支援</li><li>儼然成為 Container Management 的標準 </li></ul></li><li><strong>minikube</strong><ul><li>local 的單節點 k8s。<strong>適合拿來練習</strong></li></ul></li><li><strong>k3s</strong> (閹割)<ul><li>沒有 add-ons ，不夠彈性</li></ul></li><li><strong>microk8s</strong><ul><li>有 add-ons ，可彈性抽換不同 component</li></ul></li></ul><h2 id="What’s-the-Kubernetes"><a href="#What’s-the-Kubernetes" class="headerlink" title="What’s the Kubernetes?"></a>What’s the Kubernetes?</h2><h3 id="歷史"><a href="#歷史" class="headerlink" title="歷史"></a>歷史</h3><ol><li>Kubernetes（又稱為 k8s）是一個開放原始碼的 <strong>容器編排管理系統 container orchestrator</strong>，用於自動化應用程序的部署，擴展和管理。</li><li>Google 於 2014 年中首次宣布 Kubernetes ，現由 <a href="https://www.cncf.io/">Cloud Native Computing Foundation (CNCF)</a> 負責維護。</li><li>原以 C++ 編寫，後以 Golang 重構。</li><li>發音 koo ～ ber ～ natis，又稱作 <strong>k8s</strong>。</li></ol><h3 id="叢集架構"><a href="#叢集架構" class="headerlink" title="叢集架構"></a>叢集架構</h3><!-- ![](https://i.imgur.com/g8e8Gft.png) --><img src="https://i.imgur.com/g8e8Gft.png" width="800" height="400" /><ol><li><strong>Pod</strong> 最基本的部署單位。</li><li><strong>Service</strong> 代表一組功能相同的 Pods 群體。訪問 Service 時會自動 load balance 到該群體底下任意的 Pod 上。</li><li><strong>Label</strong> 可以將任意物件 <strong>貼上標籤</strong> ，方便將物件進行分組還有分配任務</li><li><strong>Ingress</strong> 用於管理從外部對叢集中的 <strong>Service</strong> 進行訪問（HTTP, HTTPS）。必須部署到 master node 上面。</li></ol><h3 id="系統元件"><a href="#系統元件" class="headerlink" title="系統元件"></a>系統元件</h3><!-- > FIXME: ingress service 在哪兒？ --><img src="https://i.imgur.com/zpnOfVC.png" width="800" height="450" /><ul><li><strong>master node</strong> : 負責管理和控制所有 <strong>worker node</strong> 的主機。</li><li><strong>Worker node</strong> : 運行微服務的主機。</li><li><strong>API server</strong> : 提供 Kubernetes API ，讓使用者可以透過它管理和設定整個系統。</li><li><strong>etcd</strong> : 儲存整個 k8s 叢集中物件的規格。</li><li><strong>Scheduler</strong> : 負責決定 Pod 要部署到哪一個節點上。</li><li><strong>Kubelets</strong> : <strong>視為每個節點的大腦</strong>。<ul><li>作為 master node 和 worker node 溝通的媒介。</li><li>負責管理 Pod，包括在 Pod 發生故障時創建新的 Pod。</li></ul></li><li><strong>cAdvisor</strong> : 搜集該節點上所有資源的資訊，透過 kubelet 隨時回報給 master node。</li><li><strong>Kube-Proxy</strong> : 維護節點上的網絡規則。負責網路流量的傳送。</li></ul><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul><li><p><strong>Velocity 速度</strong></p><ul><li>可達成短時間多次的不停機更新。<br><img src="https://i.imgur.com/v6vg4AW.jpg" width="550" height="325" /></br></li></ul></li><li><p><strong>Immutability 不變性</strong></p><ul><li>當軟體版本更新時<ul><li>✅ (<strong>immutable</strong>) 重新 <strong>build</strong> 一個更新的 <strong>image</strong> </li><li>❌ (<strong>mutable</strong>) 進入 <strong>container</strong> 更新 </li></ul></li></ul></li><li><p><strong>Declarative configuration 宣告式設定</strong></p><ul><li><strong>命令式命令 (imperative commands)</strong> 定義了 <strong>行為</strong> 。「執行Ａ，執行Ｂ，然後再執行Ｃ…」</li><li><strong>宣告式設定 (declarartive configurations)</strong> 定義了 <strong>狀態</strong> 。「我需要三個Ａ程式」</li></ul></li><li><p><strong>Self-healing 自我修復</strong></p><ul><li>隨時維護當前所需的狀態設定。</li></ul></li><li><p><strong>Scalability 擴展性</strong></p><ul><li>通過新增或刪除 Pod 輕鬆地上下擴展服務的工作負載。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Microservice </tag>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 Flutter 在 iOS 和 Android  上設定 GoogleMap</title>
      <link href="2020/07/09/%E4%BD%BF%E7%94%A8-Flutter-%E5%9C%A8-iOS-%E5%92%8C-Android-%E4%B8%8A%E8%A8%AD%E5%AE%9A-GoogleMap/"/>
      <url>2020/07/09/%E4%BD%BF%E7%94%A8-Flutter-%E5%9C%A8-iOS-%E5%92%8C-Android-%E4%B8%8A%E8%A8%AD%E5%AE%9A-GoogleMap/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>如果要在 iOS 或是 Android 中使用 Google 所提供的地圖或道路資訊等等，就必須要取得 Google 配給你的 <strong><code>API key</code></strong> ，而它是用來在每次請求 Google 地圖時讓 Google 可以辨認帳戶的金鑰。所以請妥善保管你的金鑰並且由於安全的緣故不要在同一個金鑰上面開起太多功能！</p><span id="more"></span><h2 id="事前準備"><a href="#事前準備" class="headerlink" title="事前準備"></a>事前準備</h2><p>所有 Google 的服務都會經過手機內的 <strong>Google Play Services</strong> 來傳輸資料。我們可以從下圖得知應用程式是只要使用到 Google 的服務都會透過 <strong><a href="https://en.wikipedia.org/wiki/Inter-process_communication">IPC</a></strong> 與 Google Play Services 做溝通的（認證、取得資訊…）</p><p><img src="https://i.imgur.com/3yZCj4y.png"></p><p>因此記得在 <strong>Android studio</strong> 中安裝 <strong>Google Play services</strong> 不然是無法取得地圖的任何資訊喔！！！</p><p><img src="https://i.imgur.com/shqRqoM.png"></p><h2 id="Android-環境設置"><a href="#Android-環境設置" class="headerlink" title="Android 環境設置"></a>Android 環境設置</h2><p>設定 <code>google map</code> 的 <strong><code>API key</code></strong> 在 <code>AndroidManifest.xml</code> 檔案中</p><p>在該路徑底下 android/app/src/main/AndroidManifest.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">...</span></span></span><br><span class="line">  &lt;application ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">meta-data</span> <span class="attr">android:name</span>=<span class="string">&quot;com.google.android.geo.API_KEY&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">android:value</span>=<span class="string">&quot;YOUR KEY HERE&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h2 id="iOS-環境設置"><a href="#iOS-環境設置" class="headerlink" title="iOS 環境設置"></a>iOS 環境設置</h2><h3 id="Step-1"><a href="#Step-1" class="headerlink" title="Step 1"></a>Step 1</h3><p>在 cmd 建立 Flutter 專案時把預設 iOS 開發語言設定成 swift</p><blockquote><p>flutter create -i swift &lt;專案名字&gt;</p></blockquote><h3 id="Step-2"><a href="#Step-2" class="headerlink" title="Step 2"></a>Step 2</h3><p>設定 <code>google map</code> 的 <strong><code>API key</code></strong> 在 <code>Appdelegate.swift</code> 檔案中</p><p>在該路徑底下 ios/Runner/AppDelegate.swift</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="keyword">import</span> Flutter</span><br><span class="line"><span class="keyword">import</span> GoogleMaps</span><br><span class="line"></span><br><span class="line"><span class="keyword">@UIApplicationMain</span></span><br><span class="line"><span class="keyword">@objc</span> <span class="class"><span class="keyword">class</span> <span class="title">AppDelegate</span>: <span class="title">FlutterAppDelegate</span> </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">application</span>(</span></span><br><span class="line"><span class="function">    <span class="keyword">_</span> <span class="params">application</span>: <span class="type">UIApplication</span>,</span></span><br><span class="line"><span class="function">    <span class="params">didFinishLaunchingWithOptions</span> <span class="params">launchOptions</span>: [<span class="params">UIApplicationLaunchOptionsKey</span>: <span class="keyword">Any</span>]<span class="operator">?</span></span></span><br><span class="line"><span class="function">  )</span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="type">GMSServices</span>.provideAPIKey(<span class="string">&quot;YOUR KEY HERE&quot;</span>)</span><br><span class="line">    <span class="type">GeneratedPluginRegistrant</span>.register(with: <span class="keyword">self</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.application(application, didFinishLaunchingWithOptions: launchOptions)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Step-3"><a href="#Step-3" class="headerlink" title="Step 3"></a>Step 3</h3><p>確保 iOS 裝置可以支援地圖渲染還需要加入以下設定在該檔案中</p><p>在該路徑底下ios/Runner/Info.plist</p><figure class="highlight plist"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>io.flutter.embedded_views_preview<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">true</span>/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="完成！！！"><a href="#完成！！！" class="headerlink" title="完成！！！"></a>完成！！！</h3>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> iOS </tag>
            
            <tag> Google Map </tag>
            
            <tag> Google Play services </tag>
            
            <tag> Flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>推播通知 Push Notification - 改變手機應用的技術</title>
      <link href="2020/03/11/%E6%8E%A8%E6%92%AD%E9%80%9A%E7%9F%A5-Push-Notification-%E6%94%B9%E8%AE%8A%E6%89%8B%E6%A9%9F%E6%87%89%E7%94%A8%E7%9A%84%E6%8A%80%E8%A1%93/"/>
      <url>2020/03/11/%E6%8E%A8%E6%92%AD%E9%80%9A%E7%9F%A5-Push-Notification-%E6%94%B9%E8%AE%8A%E6%89%8B%E6%A9%9F%E6%87%89%E7%94%A8%E7%9A%84%E6%8A%80%E8%A1%93/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>相信許多人起床的第一件事就是滑滑手機的通知，看一下有沒有新的 email 或訊息，甚至是購物平台的特價活動等等。最後再決定要不要打開那個應用程式或是一鍵清除。<em>所以如果這項技術不在我們的生活中，那我們的手機將會比宇宙還要安靜。</em> 透過伺服器主動發送訊息到客戶的手機，讓使用者可以及時地獲得各項服務的訊息通知。</p><span id="more"></span><h1 id="Firebase-Cloud-Messaging-介紹"><a href="#Firebase-Cloud-Messaging-介紹" class="headerlink" title="Firebase Cloud Messaging 介紹"></a>Firebase Cloud Messaging 介紹</h1><p><a href="https://firebase.google.com/docs/cloud-messaging/?gclid=CjwKCAjwmKLzBRBeEiwACCVihrLVkZCYLgGgoSq-qo4hRZP9u13ClyFbMIjpWQB234ZVU5W8YMjpmBoCOOQQAvD_BwE">Firebase Cloud Messaging</a> 簡稱 FCM ，它是一種跨平台的消息傳遞解決方案，可以讓服務免費的發送消息。當然數量也會有一定的限制。所以今天就是要使用 Node.js 來實作 FCM 發送消息的服務。</p><h1 id="在-Node-js-中配置-FCM"><a href="#在-Node-js-中配置-FCM" class="headerlink" title="在 Node.js 中配置 FCM"></a>在 Node.js 中配置 FCM</h1><h4 id="Step-1-安裝套件"><a href="#Step-1-安裝套件" class="headerlink" title="Step 1 安裝套件"></a>Step 1 安裝套件</h4><blockquote><p>npm install firebase-admin –save</p></blockquote><h4 id="Step-2-在專案中引入該套件"><a href="#Step-2-在專案中引入該套件" class="headerlink" title="Step 2 在專案中引入該套件"></a>Step 2 在專案中引入該套件</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> admin = <span class="built_in">require</span>(<span class="string">&#x27;firebase-admin&#x27;</span>);</span><br></pre></td></tr></table></figure><h4 id="Step-3-向-FCM-認證"><a href="#Step-3-向-FCM-認證" class="headerlink" title="Step 3 向 FCM 認證"></a>Step 3 向 FCM 認證</h4><p>將我們的 FCM 的 <a href="https://console.firebase.google.com/u/0/?pli=1">service account</a> 與我們的伺服器作認證連結</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">admin.initializeApp(&#123;</span><br><span class="line">  credential: admin.credential.applicationDefault(),</span><br><span class="line">  databaseURL: <span class="string">&#x27;https://&lt;DATABASE_NAME&gt;.firebaseio.com&#x27;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="傳送推播通知"><a href="#傳送推播通知" class="headerlink" title="傳送推播通知"></a>傳送推播通知</h1><p><img src="https://i.imgur.com/g7f4LIz.png"></p><p>經過以上的步驟我們的 Node.js 基本上就可以開始推播訊息給我們的用戶，但在這之前請確保手機的 App 已經設置好相關的 FCM sdk ，並將該用戶的 FCM token 傳送到後端並加以儲存。這是為了讓我們伺服器服務知道要推播通知給哪名使用者。</p><h3 id="對單一特定的手機裝置傳送-messages"><a href="#對單一特定的手機裝置傳送-messages" class="headerlink" title="對單一特定的手機裝置傳送 messages"></a>對單一特定的手機裝置傳送 messages</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 這個註冊的 token 是從手機端的 FCM SDKs 傳來的.</span></span><br><span class="line"><span class="keyword">var</span> registrationToken = <span class="string">&#x27;YOUR_REGISTRATION_TOKEN&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> message = &#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    score: <span class="string">&#x27;850&#x27;</span>,</span><br><span class="line">    time: <span class="string">&#x27;2:45&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  token: registrationToken</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 對這個已註冊 token 的手機裝置傳送訊息</span></span><br><span class="line">admin.messaging().send(message)</span><br><span class="line">  .then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// Response 是一個字串型別的 message ID.</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Successfully sent message:&#x27;</span>, response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Error sending message:&#x27;</span>, error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h3 id="對多個手機裝置傳送-messages"><a href="#對多個手機裝置傳送-messages" class="headerlink" title="對多個手機裝置傳送 messages"></a>對多個手機裝置傳送 messages</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以建立包含多達 100 個已註冊 token 的陣列(串列).</span></span><br><span class="line"><span class="comment">// 這些已註冊的 tokens 手機端的 FCM SDKs.</span></span><br><span class="line"><span class="keyword">const</span> registrationTokens = [</span><br><span class="line">  <span class="string">&#x27;YOUR_REGISTRATION_TOKEN_1&#x27;</span>,</span><br><span class="line">  <span class="comment">// …</span></span><br><span class="line">  <span class="string">&#x27;YOUR_REGISTRATION_TOKEN_N&#x27;</span>,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> message = &#123;</span><br><span class="line">  data: &#123;<span class="attr">score</span>: <span class="string">&#x27;850&#x27;</span>, <span class="attr">time</span>: <span class="string">&#x27;2:45&#x27;</span>&#125;,</span><br><span class="line">  tokens: registrationTokens,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">admin.messaging().sendMulticast(message)</span><br><span class="line">  .then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;response.successCount&#125;</span> messages were sent successfully`</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="對已訂閱特定主題-topics-的手機裝置傳送-messages"><a href="#對已訂閱特定主題-topics-的手機裝置傳送-messages" class="headerlink" title="對已訂閱特定主題 topics 的手機裝置傳送 messages"></a>對已訂閱特定主題 topics 的手機裝置傳送 messages</h3><p>在建立一個 <code>topic</code> 後，不是透過在手機裝置上訂閱該 <code>topic</code> 就是透過 <a href="https://firebase.google.com/docs/cloud-messaging/manage-topics?authuser=3">server API</a>.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以在 topic 名字前面選擇性地加上 &quot;/topics/&quot;.</span></span><br><span class="line"><span class="keyword">var</span> topic = <span class="string">&#x27;highScores&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> message = &#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    score: <span class="string">&#x27;850&#x27;</span>,</span><br><span class="line">    time: <span class="string">&#x27;2:45&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  topic: topic</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向已經訂閱該 topic 的手機裝置傳送訊息.</span></span><br><span class="line">admin.messaging().send(message)</span><br><span class="line">  .then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// Response 是一個字串型別的 message ID.</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Successfully sent message:&#x27;</span>, response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Error sending message:&#x27;</span>, error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>當然也有 <strong>條件主題</strong> 的功能，請查閱 <a href="https://firebase.google.com/docs/cloud-messaging/send-message?authuser=3#send_messages_to_topics">API</a></p><h3 id="批次傳送-messages"><a href="#批次傳送-messages" class="headerlink" title="批次傳送 messages"></a>批次傳送 messages</h3><p>可以將<strong>最多 100 條訊</strong>息組合在一起，然後在 <code>API</code> 呼叫中將他們一次送出去，與每次都為一條訊息發送 HTTP request 的效能上有顯著的提升. <code>e.g.</code> 當你需要同時傳送訊息到不同使用者上，而你主體的訊息內容只有些微的差異。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 建立一個最多包涵 100 條訊息的陣列(串列)。</span></span><br><span class="line"><span class="keyword">const</span> messages = [];</span><br><span class="line">messages.push(&#123;</span><br><span class="line">  notification: &#123;<span class="attr">title</span>: <span class="string">&#x27;Price drop&#x27;</span>, <span class="attr">body</span>: <span class="string">&#x27;5% off all electronics&#x27;</span>&#125;,</span><br><span class="line">  token: registrationToken,</span><br><span class="line">&#125;);</span><br><span class="line">messages.push(&#123;</span><br><span class="line">  notification: &#123;<span class="attr">title</span>: <span class="string">&#x27;Price drop&#x27;</span>, <span class="attr">body</span>: <span class="string">&#x27;2% off all books&#x27;</span>&#125;,</span><br><span class="line">  topic: <span class="string">&#x27;readers-club&#x27;</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">admin.messaging().sendAll(messages)</span><br><span class="line">  .then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response.successCount + <span class="string">&#x27; messages were sent successfully&#x27;</span>);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Node.js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Firebase Cloud Messaging </tag>
            
            <tag> Node.js </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
